# A TLA+ Proof System

## Abstract

We describe an extension to the TLA+ specification language with constructs for writing proofs and a proof environment, called the Proof Manager (PM), to checks those proofs. The language and the PM support the incremental development and checking of hierarchically structured proofs. The PM translates a proof into a set of independent proof obligations and calls upon a collection of back-end provers to verify them. Different provers can be used to verify different obligations. The currently supported back-ends are the tableau prover Zenon and Isabelle/TLA+, an axiomatisation of TLA+ in Isabelle/Pure. The proof obligations for a complete TLA+2 proof can also be used to certify the theorem in Isabelle/TLA+.

我们描述了TLA+规范语言的一个扩展，它具有编写证明的结构和一个称为证明管理器(proof Manager, PM)的证明环境，用于检查这些证明。语言和PM支持增量开发和分层结构证明的检查。PM将证明转换为一组独立的证明义务，并调用后端验证者集合来验证它们。可以使用不同的验证器来验证不同的义务。目前支持的后端是tableau prover Zenon和Isabelle/TLA+，这是Isabelle/Pure中TLA+的一个公理化。一个完整的TLA+2证明的证明义务也可以用来证明Isabelle/TLA+中的定理。

## 1 Introduction

TLA+ is a language for specifying the behavior of concurrent and distributed systems and asserting properties of those systems [11]. However, it provides no way to write proofs of those properties. We have designed an extended version of the language that allows writing proofs, and we have begun implementing a system centered around a Proof Manager (PM) that invokes existing automated and interactive proof systems to check those proofs. For now, the new version of TLA+ is called TLA+2 to distinguish it from the current one. We describe here the TLA+2 proof constructs and the current state of the proof system.

- [11] Leslie Lamport. Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers. Addison-Wesley, 2003.

TLA+是一种用于指定并发和分布式系统的行为以及断言这些系统的属性[11]的语言。但是，它没有提供编写这些属性的证明的方法。我们已经设计了一个允许编写证明的语言扩展版本，并且我们已经开始实现一个以证明管理器(PM)为中心的系统，它调用现有的自动化和交互式证明系统来检查这些证明。目前，新版本的TLA+被称为TLA+2，以区别于当前版本。我们在这里描述了TLA+2证明结构和证明系统的当前状态。

The primary goal of TLA+2 and the proof system is the mechanical verification of systems specifications. The proof system must not only support the modal and temporal aspects of TLA needed to reason about system properties, but must also support ordinary mathematical reasoning in the underlying logic. Proofs in TLA+2 are natural deduction proofs written in a hierarchical style that we have found to be good for ordinary mathematics [9] and crucial for managing the complexity of correctness proofs of systems [6].

- [9] Leslie Lamport. How to write a proof. American Mathematical Monthly, 102(7):600–608,August 1993.
- [6] Eli Gafni and Leslie Lamport. Disk Paxos. Distributed Computing, 16(1):1–20, 2003.

TLA+2和验证系统的主要目标是系统规范的机械验证。证明系统不仅要支持对系统属性进行推理所需的TLA的模态和时间方面，而且还必须支持底层逻辑中的普通数学推理。TLA+2中的证明是一种自然的推理证明，我们发现这种证明的层次结构适用于普通的数学[9]，并且对于管理系统[6]的正确性证明的复杂性至关重要。

The PM computes proof obligations that establish the correctness of the proof and sends them to one or more back-end provers to be verified. Currently, the back-end provers are Isabelle/TLA+, a faithful axiomatization of TLA+ in Isabelle/Pure, and Zenon [2], a tableau prover for classical first-order logic with equality. The PM first sends a proof obligation to Zenon. If Zenon succeeds, it produces an Isar script that the PM sends to Isabelle to check. Otherwise, the PM outputs an Isar script that uses one of Isabelle’s automated tactics. In both cases, the obligations are certified by Isabelle/TLA+. The system architecture easily accommodates other back-end provers; if these are proof-producing, then we can use their proofs to certify the obligations in Isabelle/TLA+, resulting in high confidence in the overall correctness of the proof.

PM计算证明义务，该义务建立证明的正确性，并将其发送给一个或多个后端验证者进行验证。目前，后端验证器是Isabelle/TLA+，这是Isabelle/Pure中对TLA+的一种忠实的公理化，以及Zenon[2]，这是经典一阶逻辑的等价表验证器。PM首先向Zenon发送一个证明义务。如果Zenon成功，它将生成一个Isar脚本，PM将该脚本发送给Isabelle进行检查。否则，PM输出一个使用Isabelle的自动化策略的Isar脚本。在这两种情况下，这些义务都是由Isabelle/TLA+认证的。系统架构易于容纳其他后端验证程序;如果这些是证明生成的，那么我们可以使用他们的证明来证明Isabelle/TLA+中的义务，从而对证明的整体正确性有较高的信心。

The TLA+2 proof constructs are described in Section 2. Section 3 describes the proof obligations generated by the PM, and Section 4 describes how the PM uses Zenon and Isabelle to verify them. The conclusion summarizes what we have done and not yet done and briefly discusses related work.

TLA+2证明结构将在第2节中描述。第3节描述了PM生成的证明义务，第4节描述了PM如何使用Zenon和Isabelle来验证它们。结论部分总结了我们所做的和尚未做的工作，并对相关工作进行了简要的讨论。

## 2 TLA+ and its Proof Language

### 2.1 TLA

The TLA+ language is based on the Temporal Logic of Actions (TLA) [10], a linear-time temporal logic. The rigid variables of TLA are called constants and the flexible variables are called simply variables. TLA assumes an underlying ordinary (non-modal) logic for constructing expressions. Operators of that logic are called constant operators. A state function is an expression built from constant operators and TLA constants and variables. The elementary (non-temporal) formulas of TLA are actions, which are formulas built with constant operators, constants, variables, and expressions of the form f ′, where f is a state function. (TLA also has an enabled operator that is used in expressing fairness, but we ignore it for brevity.) An action is interpreted as a predicate on pairs of states that describes a set of possible state transitions, where state functions refer to the starting state and primed state functions refer to the ending state. Because priming distributes over constant operators and because c′ is equal to c for any constant c, an action can be reduced to a formula built from constant operators, constants, variables, and primed variables.

- [10] Leslie Lamport. The temporal logic of actions. ACM Transactions on Programming Languages and Systems, 16(3):872–923,May 1994.

TLA+语言基于动作的时间逻辑(TLA)[10]，一个线性时间的时间逻辑。TLA的刚性变量称为常数，而柔性变量称为简单变量。TLA采用底层的普通(非模态)逻辑来构造表达式。这种逻辑的运算符称为常数运算符。状态函数是由常数运算符、TLA常数和变量构成的表达式。TLA的基本(非时态)公式是action，它是由常数运算符、常数、变量和f '的表达式构成的公式，其中f是一个状态函数。(TLA还有一个用于表示公平性的启用操作符，但是为了简洁，我们忽略了它。)动作被解释为对状态的谓词，这些状态描述了一组可能的状态转换，其中状态函数引用起始状态，启动状态函数引用结束状态。因为启动分布在常数算子上因为c '对于任何常数c都等于c，一个作用可以被简化成一个公式由常数算子，常数，变量，和被启动的变量组成。

TLA is practical for describing systems because all the complexity of a specification is in the action formulas. Temporal operators are essentially used only to assert liveness properties, including fairness of system actions. Most of the work in a TLA proof is in proving action formulas; temporal reasoning occurs only in proving liveness properties and is limited to propositional temporal logic and to applying a handful of proof rules whose main premises are action formulas. Because temporal reasoning is such a small part of TLA proofs, we have deferred its implementation. The PM now handles only action formulas. We have enough experience mechanizing TLA’s temporal reasoning [4] to be fairly confident that it will not be hard to extend the PM to support it.

- [4] Urban Engberg, Peter Grønning, and Leslie Lamport. Mechanical verification of concurrent systems with TLA. In G. v. Bochmann and D. K. Probst, editors, Proc. 4th CAV, volume 663 of Lecture Notes in Computer Science, pages 44–55. Springer-Verlag, June 1992.

TLA对于描述系统是实用的，因为规范的所有复杂性都在操作公式中。时态操作符本质上仅用于断言活性属性，包括系统操作的公平性。TLA证明的主要工作是证明作用公式;时间推理仅发生在证明活性属性，仅限于命题时间逻辑和应用少量的证明规则，其主要前提是动作公式。因为时间推理是TLA证明的一小部分，我们推迟了它的实现。PM现在只处理动作公式。我们有足够的经验来机械化TLA的时间推理[4]，因此我们有足够的信心来扩展PM来支持它。

A formula built from constant operators, constants, variables, and primed variables is valid iff it is a valid formula of the underlying logic when constants, variables, and primed variables are treated as distinct variables of the logic—that is, if v and v′ are considered to be two distinct variables of the underlying logic, for any TLA variable v. Since any action formula is reducible to such a formula, action reasoning is immediately reducible to reasoning in the underlying logic. We therefore ignore variables and priming here and consider only constant formulas.

公式由常数运营商,常量,变量,和主要的变量是有效的敌我识别是有效公式的基本逻辑常量时,变量,和主要的变量被当作不同的变量的逻辑是,如果v, v′被认为是两个不同的变量的逻辑,任何行动以来任何TLA变量诉公式简化为这样一个公式,行动推理是立即可约在底层逻辑推理。因此，我们在这里忽略变量和启动，只考虑常数公式。

### 2.2 TLA+

The TLA+ language adds the following to the TLA logic: 
- An underlying logic that is essentially ZFC set theory plus classical untyped first-order logic with Hilbert’s ε [13]. The major difference between this underlying logic and traditional ZFC is that functions are defined axiomatically rather than being represented as sets of ordered pairs. 
- A mechanism for defining operators, where a user-defined operator is essentially a macro that is expanded syntactically. (TLA+ permits recursive function definitions, but they are translated to ordinary definitions using Hilbert’s ε.) 
- Modules, where one module can import definitions and theorems from other modules. A module is parameterized by its declared variables and constants, and it may be instantiated in another module by substituting expressions for its parameters. The combination of substitution and the enabled operator introduces some complications, but space limitations prevent us from discussing them, so we largely ignore modules in this paper.

TLA+语言在TLA逻辑中增加了以下内容:
- 一个潜在的逻辑本质上是ZFC集合理论+经典无类型的一阶逻辑与希尔伯特的ε[13]。这种底层逻辑与传统的ZFC之间的主要区别是，函数是按公理定义的，而不是表示为有序对的集合。
- 一种定义运算符的机制，用户定义的运算符本质上是一个在语法上展开的宏。(TLA +允许递归函数的定义,但它们是普通翻译定义使用希尔伯特的ε。)
- 模块，其中一个模块可以从其他模块导入定义和定理。一个模块是由它声明的变量和常量参数化的，它可以在另一个模块中通过用表达式替换它的参数来实例化。置换和使能运算符的结合引入了一些复杂性，但是由于空间的限制，我们无法对其进行讨论，因此在本文中我们基本忽略了模块。

TLA+ has been extensively documented [11]. Since we are concerned only with reasoning about its underlying logic, which is a very familiar one, we do not bother to describe TLA+ in any detail. All of its nonstandard notation that appears in our examples is explained.

- [11] Leslie Lamport. Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers. Addison-Wesley, 2003.

TLA+已被广泛记录为[11]。因为我们只关心它的底层逻辑的推理，这是一个非常熟悉的逻辑，所以我们不需要详细描述TLA+。在我们的例子中出现的所有非标准符号都得到了解释。

### 2.3 The Proof Language

The major new feature of TLA+2 is its proof language. (For reasons having nothing to do with proofs, TLA+2 also introduces recursive operator definitions, which we ignore here for brevity.) We describe the basic proof language, omitting a few constructs that concern aspects such as module instantiation that we are not discussing. TLA+2 also adds constructs for naming subexpressions of a definition or theorem, which is important in practice for writing proofs but is orthogonal to the concerns of this paper.

TLA+2的主要新特性是它的证明语言。(由于与证明无关的原因，TLA+2还引入了递归运算符定义，为了简洁起见，我们在这里忽略它。)我们描述了基本的证明语言，省略了一些涉及到模块实例化等方面的构造，我们没有讨论这些方面。TLA+2还为定义或定理的子表达式命名添加了结构，这在编写证明的实践中很重要，但与本文的关注点是正交的。

The goal of the language is to make proofs easy to read and write for someone with no knowledge of how the proofs are being checked. This leads to a mostly declarative language, built around the uses and proofs of assertions rather than around the application of proof-search tactics. It is therefore more akin to Isabelle/Isar [17] than to more operational interactive languages such as Coq’s Vernacular [16]. Nevertheless, the proof language does include a few operational constructs that can eliminate the repetition of common idioms, albeit with some loss of perspicuity.

该语言的目标是使证明易于阅读和编写，对于不知道如何检查证明的人来说。这导致了一种主要是声明性语言，围绕断言的使用和证明构建，而不是围绕证明搜索策略的应用。因此，它更类似于Isabelle/Isar[17]，而不是更具操作性的交互式语言，如Coq的本地语言[16]。尽管如此，证明语言确实包含了一些操作结构，可以消除常见习语的重复，尽管这样做会丧失一些敏锐性。

At any point in a TLA+ proof, there is a current obligation that is to be proved. The obligation contains a context of known facts, definitions, and declarations, and a goal. The obligation claims that the goal is logically entailed by the context. Some of the facts and definitions in the context are marked (explicitly or implicitly) as usable for reasoning, while the remaining facts and definitions are hidden.

在TLA+证据的任何点上，都有一个当前的义务需要被证明。该义务包含已知事实、定义、声明和目标的上下文。义务声称目标在逻辑上是由上下文引起的。上下文中的一些事实和定义被标记(显式或隐式)为可用于推理，而其余的事实和定义则被隐藏。

Proofs are structured hierarchically. The leaf (lowest-level) proof obvious asserts that the current goal follows easily from the usable facts and definitions. The leaf proof 
$BY e_1,...,e_m DEFS o_1, . . . ,o_n$
asserts that the current goal follows easily from the usable facts and definitions together with (i) the facts ei that must themselves follow easily from the context and (ii) the known definitions of oj. Whether a goal follows easily from definitions and facts depends on who is trying to prove it. For each leaf proof, the PM sends the corresponding leaf obligation to the back-end provers, so in practice “follows easily” means that a back-end prover can prove it. A non-leaf proof is a sequence of steps, each consisting of a begin-step token and a proof construct. For some constructs (including a simple assertion of a proposition) the step takes a subproof, which may be omitted. The final step in the sequence simply asserts the current goal, which is represented by the token qed. A begin-step token is either a level token of the form hni or a label of the form hnil, where n is a level number that is the same for all steps of this non-leaf proof, and l is an arbitrary name. The hierarchical structure is deduced from the level numbers of the begin-step tokens, a higher level number beginning a subproof.

证明是分层结构的。leaf(最低级别)证明明显地断言，当前目标很容易从可用的事实和定义中遵循。叶的证据

$BY e_1,...,e_m DEFS o_1, . . . ,o_n$

断言当前的目标很容易从可用的事实和定义以及(i)事实本身必须很容易从上下文遵循的ei和(ii) oj的已知定义遵循。目标是否容易遵循定义和事实取决于谁试图证明它。对于每个叶子证明，PM将相应的叶子义务发送给后端验证者，因此在实践中“容易遵循”意味着后端验证者可以证明它。非叶证明是一系列的步骤，每个步骤由一个起始步标记和一个证明结构组成。对于某些构造(包括一个简单的命题断言)，步骤采用子证明，可以忽略它。序列中的最后一步只是断言当前目标，它由标记qed表示。begin-step令牌可以是表单hni的级别令牌，也可以是表单hnil的标签，其中n是一个级别号，对于这个非叶证明的所有步骤都是相同的，而l是一个任意的名称。层次结构从起始步骤标记的级别号推导而来，起始子证明的级别号更高。

Some steps make declarations or definitions or change the current goal and do not require a proof. Other steps make assertions that become the current goals for their proofs. An omitted proof (or one consisting of the token omitted) is considered to be a leaf proof that instructs the assertion to be accepted as true. Of course, the proof is then incomplete. From a logical point of view, an omitted step is the same as an additional assumption added to the theorem; from a practical point of view, it doesn’t have to be lifted from its context and stated at the start. Omitted steps are intended to be used only in the intermediate stages of writing a proof.

有些步骤不需要证明就可以声明或定义或更改当前目标。其他步骤使断言成为其证明的当前目标。一个被忽略的证明(或一个由被忽略的标记组成的证明)被认为是一个叶子证明，它指示断言被接受为真。当然，这个证明是不完整的。从逻辑的观点来看，省略的步骤就相当于在定理中增加了一个附加的假设;从实用的角度来看，它不需要从上下文中提取出来并在一开始就加以说明。省略的步骤只在编写证明的中间阶段使用。

Following a step that makes an assertion (and the step’s proof), until the end of the current proof (after the qed step), the contexts contain that assertion in their sets of known facts. The assertion is marked usable iff the begin-step token is a level token; otherwise it can be referred to by its label in a by proof or made usable with a use step.

在生成断言(以及该步骤的证明)的步骤之后，直到当前证明结束(在qed步骤之后)，上下文在其已知事实集中包含该断言。如果begin-step令牌是一个级别令牌，则断言被标记为可用;否则，它可以引用其标签在一个证明或使可用的使用步骤。

The hierarchical structure of proofs not only aids in reading the finished proof but is also quite useful in incrementally writing proofs. The steps of a non-leaf proof are first written with all proofs but that of the qed step omitted. After checking the proof of the qed step, the proofs omitted for other steps in this or earlier levels are written in any order. When writing the proof, one may discover facts that are needed in the proofs of multiple steps. Such a fact is then added to the proof as an earlier step, or added at a higher level. It can also be removed from the proof of the theorem and proved separately as a lemma. However, the hierarchical proof language encourages facts relevant only for a particular proof to be kept within the proof, making the proof’s structure easier to see and simplifying maintenance of the proof. For correctness proofs of systems, the first few levels of the hierarchy are generally determined by the structure of the formula to be proved—for example, the proof that a formula implies a conjunction usually consists of steps asserting that it implies each conjunct.

证明的层次结构不仅有助于阅读已完成的证明，而且在增量式编写证明中也非常有用。非叶证明的步骤是先写所有的证明，但qed的步骤省略。在检查了qed步骤的证明之后，在这一层或更早的层中省略的其他步骤的证明可以按任何顺序编写。在编写证明时，可以发现在多个步骤的证明中需要的事实。这样一个事实随后被作为一个较早的步骤添加到证明中，或者在更高的层次上添加。它也可以从定理的证明中移除，作为引理单独证明。但是，分级证明语言鼓励只在证明中保留与特定证明相关的事实，从而使证明的结构更容易看到，并简化了证明的维护。对于系统的正确性证明，层次结构的前几级通常由要证明的公式的结构决定——例如，一个公式包含一个连接的证明通常由断言它包含每个连接的步骤组成。

As an example, we incrementally construct a hierarchical proof of Cantor’s theorem, which states that there is no surjective function from a set to its powerset. It is written in TLA+ as:

$THEOREM \forall S:\forall f\in [ S \rightarrow SUBSET S ]: \exists A \in SUBSET S: \forall x \in S:f(x)\neq A$

## 3 Proof Obligations

## 4 Verifying Proof Obligations

Once the PM generates the leaf obligations, it must send them to the back-end provers. The one nonobvious part of doing this is deciding whether definitions should be expanded by the PM or by the prover. This is discussed in Section 4.1. We then describe the state of our two current back-end provers, Isabelle/TLA+ and Zenon.

一旦PM生成了叶子义务，它就必须将它们发送到后端provers。这样做的一个不明显的部分是决定定义应该由PM扩展还是由验证者扩展。这将在4.1节中讨论。然后我们将描述我们当前的两个后端provers, Isabelle/TLA+和Zenon的状态。

### 4.1 Expanding Definitions

Expansion of usable definitions cannot be left entirely to the back-end prover. The PM itself must do it for two reasons: 
- It must check that the current goal has the right form for a take, witness, or have step to be meaningful, and this can require expanding definitions. 
- The encoding of TLA+ in the back-end prover’s logic would be unsound if a modal operator like prime (′) were encoded as a non-modal operator. Hence, encoding a definition like $O(x) \triangleq x'$ as an ordinary definition in the prover’s logic would be unsound. All instances of such operators must be removed by expanding their definitions before a leaf obligation is sent to the back-end prover. Such operator definitions seldom occur in actual TLA+ specifications, but the PM must be able to deal with them.

可用定义的扩展不能完全留给后端验证程序。PM本身必须这样做，原因有两个:
- 它必须检查当前目标是否具有正确的形式，以便采取、见证或有意义的步骤，这可能需要扩展定义。
- 如果像prime(')这样的模态运算符被编码为非模态运算符，那么后端验证器逻辑中的TLA+编码就不可靠。因此，将像$O(x) \triangleq x'$这样的定义编码为验证者逻辑中的普通定义是不合理的。在将leaf义务发送到后端验证程序之前，必须通过扩展这些操作符的定义来删除它们的所有实例。这样的操作符定义很少出现在实际的TLA+规范中，但是PM必须能够处理它们。

Another reason for the PM to handle definition expansion is that the Isabelle/TLA+ object logic does not provide a direct encoding of definitions made within proofs. We plan to reduce the amount of trusted code in the PMby lambda-lifting all usable definitions out of each leaf obligation and introducing explicit operator definitions using Isabelle’s meta equality (≡). These definitions will be expanded before interacting with Isabelle.

PM处理定义扩展的另一个原因是Isabelle/TLA+对象逻辑不提供在证明中生成的定义的直接编码。我们计划通过lambda—从每个叶子义务中提取所有可用定义，并使用Isabelle的元相等(≡)引入显式操作符定义，从而减少PM中受信任代码的数量。在与Isabelle进行交互之前，将对这些定义进行扩展。

### 4.2 Isabelle/TLA+

The core of TLA+2 is being encoded as a new object logic Isabelle/TLA+ in the proof assistant Isabelle [14]. One of Isabelle’s distinctive features that similar proof assistants such as Coq [16] or HOL [7, 8] lack is genericity with respect to different logics. The base system Isabelle/Pure provides the trusted kernel and a framework in which the syntax and proof rules of object logics can be defined. We have chosen to encode TLA+2 as a separate object logic rather than add it on top of one of the existing logics (such as ZF or HOL). This simplifies the translation and makes it easier to interpret the error messages when Isabelle fails to prove obligations. A strongly typed logic such as HOL would have been unsuitable for representing TLA+2, which is untyped. Isabelle/ZF might seem like a natural choice, but differences between the way it and TLA+ define functions and tuples would have made the encoding awkward and would have prevented us from reusing existing theories. Fortunately, the genericity of Isabelle helped us not only to define the new logic, but also to instantiate the main automated proof methods, including rewriting, resolution- and tableau provers, and case-based and inductive reasoning. Adding support for more specialized reasoning tools such as proof-producing SAT solvers [5] or SMT solvers such as haRVey [3] will be similarly helped by existing generic interfaces.

TLA+2的核心在证据助手Isabelle[14]中被编码为一个新的对象逻辑Isabelle/TLA+。Isabelle的一个与众不同的特点是，类似的证明助手，如Coq[16]或HOL[7,8]的缺乏是一般性的不同的逻辑。基础系统Isabelle/Pure提供了一个可信任的内核和一个框架，在这个框架中可以定义对象逻辑的语法和证明规则。我们选择将TLA+2编码为一个单独的对象逻辑，而不是将其添加到现有逻辑(如ZF或HOL)之上。这简化了转换，并使Isabelle无法证明义务时更容易解释错误消息。像HOL这样的强类型逻辑不适合表示无类型的TLA+2。Isabelle/ZF可能看起来是一个自然的选择，但是它和TLA+定义函数和元组的方式之间的差异会使编码变得笨拙，并且会阻止我们重用现有的理论。幸运的是，Isabelle的通用性不仅帮助我们定义了新的逻辑，而且还实例化了主要的自动证明方法，包括重写、解析和tableau provers，以及基于案例的归纳推理。增加对更专门的推理工具的支持，例如生成验证的SAT求解器[5]或SMT求解器haRVey[3]，也将类似地得到现有通用接口的帮助。

The current encoding supports only a core subset of TLA+2, including propositional and first-order logic, elementary set theory, functions, and the construction of natural numbers. Support for arithmetic, strings, tuples, sequences, and records is now being added; support for the modal part of TLA+2 (variables, priming, and temporal logic) will be added later. Nevertheless, the existing fragment can already be used to test the interaction of the PM with Isabelle and other back-end provers. As explained above, Isabelle/TLA+ is used both as a back-end prover and to check proof scripts produced by other back-end provers such as Zenon. If it turns out to be necessary, we will enable the user to invoke one of Isabelle’s automated proof methods (such as auto or blast) by using a dummy theorem, as explained at the end of Section 2.3. If the method succeeds, one again obtains an Isabelle theorem. Of course, Isabelle/TLA+ can also be used independently of the PM, which is helpful when debugging tactics.

目前的编码只支持TLA+2的一个核心子集，包括命题和一阶逻辑、基本集合理论、函数和自然数的构造。现在正在添加对算术、字符串、元组、序列和记录的支持;稍后将添加对TLA+2的模态部分(变量、启动和时间逻辑)的支持。尽管如此，现有的片段已经可以用来测试PM与Isabelle和其他后端验证程序的交互。如上所述，Isabelle/TLA+既用作后端验证器，也用于检查由其他后端验证器(如Zenon)生成的验证脚本。如果它是必要的，我们将允许用户使用一个哑定理来调用Isabelle的自动证明方法(如auto或blast)，如第2.3节末尾所解释的那样。如果这个方法成功了，我们又得到了一个伊莎贝尔定理。当然，Isabelle/TLA+也可以独立于PM使用，这在调试策略时很有帮助。

### 4.3 Zenon

Zenon [2] is a tableau prover for classical first-order logic with equality that was initially designed to output formal proofs checkable by Coq [16]. Zenon outputs proofs in an automatically-checkable format and it is easily extensible with new inference rules. One of its design goals is predictability in solving simple problems, rather than high performance in solving some hard problems. These characteristics make it well-suited to our needs.

Zenon[2]是一个经典的一阶逻辑等式的表证明，它最初被设计用来输出可被Coq[16]检查的形式证明。Zenon以一种可自动检查的格式输出证明，并且可以通过新的推理规则轻松扩展。它的设计目标之一是解决简单问题的可预测性，而不是解决一些难题的高性能。这些特点使它非常适合我们的需要。

We have extended Zenon to output Isar proof scripts for Isabelle/TLA+ theorems, and the PM uses Zenon as a back-end prover, shipping the proofs it produces to Isabelle to certify the obligation. We have also extended Zenon with direct support for the TLA+2 logic, including definitions and rules about sets and functions. Adding support in the form of rules (instead of axioms) is necessary because some rules are not expressible as first-order axioms, notably the rules about the set constructs:

我们扩展了Zenon以输出Isabelle/TLA+定理的Isar证明脚本，PM使用Zenon作为后端证明程序，将生成的证明发送给Isabelle以证明该义务。我们还扩展了Zenon，直接支持TLA+2逻辑，包括关于集合和函数的定义和规则。以规则(而不是公理)的形式添加支持是必要的，因为有些规则不能表示为一阶公理，特别是关于集合结构的规则:

Even for the rules that are expressible as first-order axioms, adding them as rules makes the proof search procedure much more efficient in practice. The most important example is extensionality: when set extensionality and function extensionality are added as axioms, they apply to every equality deduced by the system, and pollute the search space with large numbers of irrelevant formulas. By adding them as rules instead, we can use heuristics to apply them only in cases where they have some chance of being useful.

即使对于可表示为一阶公理的规则，将它们作为规则加入，也使证明搜索过程在实践中更加有效。最重要的例子就是可拓性:当集合可拓性和函数可拓性作为公理时，它们适用于系统推导出的每一个等式，并且用大量不相关的公式污染了搜索空间。通过将它们添加为规则，我们可以使用启发式来仅在它们有可能有用的情况下应用它们。

Adding support for arithmetic, strings, tuples, sequences, and records will be done in parallel with the corresponding work on Isabelle/TLA+, to ensure that Zenon will produce proof scripts that Isabelle/TLA+ will be able to check. Temporal logic will be added later. We also plan to interface Zenon with Isabelle, so it can be called by a special Isabelle tactic the same way other tools are. This will simplify the PM by giving it a uniform interface to the back-end provers. It will also allow using Zenon as an Isabelle tactic independently of TLA+.

增加对算术、字符串、元组、序列和记录的支持将与Isabelle/TLA+上的相应工作并行进行，以确保Zenon将生成Isabelle/TLA+能够检查的证明脚本。稍后将添加时态逻辑。我们还计划将Zenon与Isabelle接口，这样它就可以像其他工具一样被特殊的Isabelle策略调用。这将通过为PM提供与后端验证程序的统一接口来简化PM。它还将允许使用Zenon作为伊莎贝尔TLA +独立策略。

## 5 Conclusions and Future Work

We have presented a hierarchically structured proof language for TLA+. It has several important features that help in managing the complexity of proofs. The hierarchical structure means that changes made at any level of a proof are contained inside that level, which helps construct and maintain proofs. Leaf proofs can be omitted and the resulting incomplete proof can be checked. This allows different parts of the proof to be written separately, in a non-linear fashion. The more traditional linear proof style, in which steps that have not yet been proved can be used only if explicitly added as hypotheses, encourages proofs that use many separate lemmas. Such proofs lack the coherent structure of a single hierarchical proof.

提出了一种分层结构的TLA+证明语言。它有几个重要的特性，有助于管理证明的复杂性。层次结构意味着在证明的任何级别所做的更改都包含在该级别中，这有助于构造和维护证明。可以省略叶证明，并且可以检查产生的不完整证明。这允许以非线性的方式分别编写证明的不同部分。更传统的线性证明风格鼓励使用许多独立引理的证明，在这种风格中，尚未被证明的步骤只能在明确添加为假设的情况下使用。这种证明缺乏单一层次证明的一致结构。

The proof language lets the user freely and repeatedly make facts and definitions usable or hidden. Explicitly stating what is being used to prove each step makes the proof easier for a human to understand. It also aids a back-end prover by limiting its search for a proof to ones that use only necessary facts.

证明语言允许用户自由地、反复地使事实和定义可用或隐藏。明确地说明用来证明每一步的内容会使证明更容易被人理解。它还通过限制对仅使用必要事实的证明的搜索来帮助后端验证程序。

There are other declarative proof languages that are similar to TLA+2. Isar [17] is one such language, but it has significant differences that encourage a different style of proof development. For example, it provides an accumulator facility to avoid explicit references to proof steps. This is fine for short proofs, but in our experience does not work well for long proofs that are typical of algorithm verification that TLA+2 targets. Moreover, because Isabelle is designed for interactive use, the effects of the Isar proof commands are not always easily predictable, and this encourages a linear rather than hierarchical proof development style. The Focal Proof Language [1] is essentially a subset of the TLA+2 proof language. Our experience with hierarchical proofs in Focal provides additional confidence in the attractiveness of our approach. We know of no declarative proof language that has as flexible a method of using and hiding facts and definitions as that of TLA+2.

还有其他类似于TLA+2的声明性证明语言。Isar[17]就是这样一种语言，但是它有显著的差异，这鼓励了不同风格的证明开发。例如，它提供了一个累加器工具来避免对证明步骤的显式引用。这对于较短的证明是可以的，但是根据我们的经验，对于TLA+2目标的算法验证的典型的长证明并不适用。此外，因为Isabelle是为交互式使用而设计的，Isar证明命令的效果并不总是很容易预测的，这鼓励采用线性而不是分层的证明开发风格。焦点证明语言[1]本质上是TLA+2证明语言的一个子集。我们在Focal中使用分层证明的经验为我们的方法的吸引力提供了额外的信心。据我们所知，没有一种声明式证明语言能像TLA+2那样灵活地使用和隐藏事实和定义。

The PM transforms a proof into a collection of proof obligations to be verified by a back-end prover. Its current version handles proofs of theorems in the non-temporal fragment of TLA+ that do not involve module instantiation (importing of modules with substitution). Even with this limitation, the system can be useful for many engineering applications. We are therefore concentrating on making the PM and its back-end provers handle this fragment of TLA+ effectively before extending them to the complete language. The major work that remains to be done on this is to complete the Zenon and Isabelle inference rules for reasoning about the built-in constant operators of TLA+. There are also a few non-temporal aspects of the TLA+2 language that the PM does not yet handle, such as subexpression naming. We also expect to extend the PM to support additional back-end provers, including decision procedures for arithmetic and for propositional temporal logic.

PM将一个证明转换为一个由后端验证程序验证的证明义务集合。它的当前版本处理TLA+的非时间片段中不涉及模块实例化(通过替换导入模块)的定理的证明。即使有这样的局限性，该系统仍然可以用于许多工程应用程序。因此，我们专注于让PM和它的后端provers在扩展到完整的语言之前有效地处理TLA+的这个片段。在这方面需要做的主要工作是完成Zenon和Isabelle推理规则，用于对TLA+的内置常数运算符进行推理。PM还没有处理TLA+2语言的一些非时态方面，比如子表达式命名。我们还希望扩展PM以支持其他后端验证程序，包括用于算术和命题时态逻辑的决策过程。

We do not anticipate that any major changes will be needed to the TLA+2 proof language. We do expect some minor tuning as we get more experience using it. For example, we are not sure whether local definitions should be usable by default. A graphical user interface is being planned for the TLA+ tools, including the PM. It will support the non-linear development of proofs that the language and the proof system allow.

我们不期望TLA+2证明语言会有任何大的变化。当我们获得更多使用它的经验时，我们确实希望进行一些小的调优。例如，我们不确定本地定义在默认情况下是否可用。TLA+工具的图形用户界面正在计划中，包括PM。它将支持语言和证明系统所允许的非线性证明的发展。




