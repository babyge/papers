# Don’t Sweat the Small Stuff - Formal Verification of C Code Without the Pain

# Abstract

We present an approach for automatically generating provably correct abstractions from C source code that are useful for practical implementation verification. The abstractions are easier for a human verification engineer to reason about than the implementation and increase the productivity of interactive code proof. We guarantee soundness by automatically generating proofs that the abstractions are correct.

我们提供了一种从C源代码自动生成可证明正确的抽象的方法，这些抽象对于实际的实现验证非常有用。对于人工验证工程师来说，抽象比实现更容易推理，并且可以提高交互式代码证明的生产率。我们通过自动生成证明来保证抽象是正确的。

In particular, we show two key abstractions that are critical for verifying systems-level C code: automatically turning potentially overflowing machine-word arithmetic into ideal integers, and transforming low-level C pointer reasoning into separate abstract heaps. Previous work carrying out such transformations has either done so using unverified translations, or required significant proof engineering effort.

特别地，我们展示了对验证系统级C代码至关重要的两个关键抽象:自动将可能溢出的机器字算术转换为理想整数，以及将低级C指针推理转换为单独的抽象堆。以前执行这种转换的工作要么使用了未经验证的翻译，要么需要大量的工程证明工作。

We implement these abstractions in an existing proof-producing specification transformation framework named AutoCorres, developed in Isabelle/HOL, and demonstrate its effectiveness in a number of case studies. We show scalability on multiple OS microkernels, and we show how our changes to AutoCorres improve productivity for total correctness by porting an existing high-level verification of the Schorr-Waite algorithm to a low-level C implementation with minimal effort.

我们在Isabelle/HOL开发的一个名为AutoCorres的现有证明生成规范转换框架中实现了这些抽象，并在大量案例研究中演示了它的有效性。我们展示了在多个OS微内核上的可伸缩性，并展示了我们对AutoCorres的更改如何通过将现有的Schorr-Waite算法的高级验证以最小的努力移植到低级C实现来提高总体正确性的生产率。

## 1. Introduction

Recent successes like the verified CompCert compiler [17] and the seL4 microkernel [15] show that the verification of low-level systems code has become feasible, although the effort expended for these verifications is still high: the seL4 team reports 20 person years for 10 000 source lines of C code. Formal verification at this low level is especially important in safety and security critical systems, such as operating systems, real-time systems, or language runtimes, where higher-level programming languages are not appropriate.

最近的成功，如已验证的CompCert编译器[17]和seL4微内核[15]，显示了对低级系统代码的验证已经变得可行，尽管这些验证花费的精力仍然很高:seL4团队报告说，为1万行C代码花费了20年的时间。在安全性和安全性关键系统(如操作系统、实时系统或语言运行时)中，这个低级别的正式验证尤其重要，在这些系统中，高级编程语言不适合使用。

There are two broad approaches to low-level software verification. The first is push-button verification, where even a relatively unskilled user can use an automated verification tool to quickly verify specific properties about her program, e.g., using software model checking [3, 12]. While theoretically any property might be checkable, practical success at scale has been achieved only for specific domains, such as using APIs in correct sequence, avoiding buffer overflows, or undefined behaviour. The second approach is interactive verification, which requires skilled users and greater time investment, but is able to verify deeper properties about the system, such as the two landmark verifications [15, 17] mentioned above. This approach is more flexible; the verification engineer has complete freedom in style and form of properties as well as semantic depth. She can for instance reason simultaneously about a program with a VCG [30], prove refinement to a higher-level specification [7], and prove more complex properties such as non-interference [20].

有两种广泛的低级软件验证方法。第一种是按钮验证，即使是相对不熟练的用户也可以使用自动验证工具来快速验证她的程序的特定属性，例如，使用软件模型检查[3,12]。虽然理论上任何属性都可能是可检查的，但实际的成功只是针对特定的领域，比如按照正确的顺序使用api、避免缓冲区溢出或未定义的行为。第二种方法是交互验证，它需要熟练的用户和更大的时间投入，但能够验证系统更深层的属性，如上文提到的两个里程碑式的验证[15,17]。这种方法更灵活;验证工程师在属性的样式和形式以及语义深度方面有完全的自由。例如，她可以用VCG[30]同时推理一个程序，证明细化到更高级别的规范[7]，并证明更复杂的属性，如不干涉[20]。

Much work has focused on making the automated systems in the first approach more powerful. The goal of our work is to simplify the interactive second approach and to drastically increase its productivity, while simultaneously maintaining the soundness guarantees the approach provides. C verification projects report that a large part of C verification deals with mechanical complexities of the C semantics, not with key ideas of the underlying algorithms [30]. In our AutoCorres tool1, we deal with the uninteresting complexities of C automatically, allowing the user to focus her human creativity on the algorithmic parts of verification. We do this by performing automatic, proof-producing specification abstraction, transforming a low-level specification in multiple steps into a more abstract one. AutoCorres presents to the end user a representation of the program that is simpler to reason about, while additionally producing a proof that the original program is a formal refinement of the final representation.

许多工作都集中在使第一种方法中的自动化系统更强大上。我们的工作目标是简化交互式第二种方法，并大幅提高其生产率，同时保持该方法提供的可靠性保证。C验证项目报告说，大部分C验证处理的是C语义的机械复杂性，而不是底层算法[30]的关键思想。在AutoCorres工具中，我们自动处理枯燥复杂的C语言，允许用户将其人类创造力集中在验证的算法部分。我们通过执行自动的、生成验证的规范抽象来实现这一点，将多个步骤中的低级规范转换为更抽象的规范。AutoCorres向最终用户提供了一个更容易推理的程序表示，同时生成一个证明，证明原始程序是对最终表示的正式细化。

Specification abstraction has constraints that do not apply to push-button verification. Firstly, we generate a single output per program that has to be general enough not to sacrifice the flexibility and freedom of the verification engineer in her choice of property, program logic, or semantic depth. Secondly, our output specification needs to be usable and readable by humans. CEGAR, for instance, performs automatic abstraction and refinement by avoiding counter examples generated by an SMT solver. This provides good results, but a new model is automatically generated for each property of interest, and these final models are unlikely to be human readable. Finally, we aim at higher correctness assurance than other typical automated methods: our transformation steps produce formal LCFstyle proofs in Isabelle/HOL [21].

规范抽象具有不能应用于按钮验证的约束。首先，我们为每个程序生成一个单独的输出，该输出必须足够通用，不能牺牲验证工程师在属性、程序逻辑或语义深度选择上的灵活性和自由。其次，我们的输出规范需要对人是可用的和可读的。例如，CEGAR通过避免由SMT求解器生成的反例来执行自动抽象和细化。这提供了很好的结果，但是会为每个感兴趣的属性自动生成一个新的模型，并且这些最终的模型不太可能是人类可读的。最后，我们的目标是比其他典型自动化方法更高的正确性保证:我们的转换步骤在Isabelle/HOL[21]中生成正式的LCFstyle证明。

This paper extends the existing AutoCorres tool by Greenaway et al. [11] that transforms a C program into a shallow monadic embedding in the specification abstraction style described above. While previously AutoCorres performed well at control flow abstraction, it lacked abstraction support for primitive C data types such as 32- or 64-bit machine words and for pointer reasoning. Both are the source of considerable effort in C verification. Reasoning about ideal integers instead of finite words is a key difference between algorithm verification and C implementation verification, and low-level heapbased programs are of course prevalent in systems code. In a correct C implementation of an abstract algorithm, these details will typically not play a major role. This means, ideally, the user should automatically be presented with integers instead of machine words and with an abstract heap model instead of low-level C memory detail. Both are hard problems to solve automatically.

本文通过Greenaway等人[11]对现有的AutoCorres工具进行了扩展，该工具将一个C程序转换为一个嵌入在上述规范抽象风格中的浅单元。虽然以前AutoCorres在控制流抽象方面表现良好，但它缺乏对基本C数据类型(如32位或64位机器字)和指针推理的抽象支持。两者都是C验证中大量工作的来源。对理想整数而不是有限词的推理是算法验证和C实现验证之间的关键区别，而基于底层堆的程序当然在系统代码中很普遍。在抽象算法的正确C实现中，这些细节通常不会起到主要作用。s意味着，理想情况下，用户应该使用整数而不是机器字，并使用抽象堆模型而不是低级C内存细节。这两个问题都很难自动解决。

The contribution of this paper is to solve both of them by extending AutoCorres with two key abstractions that make it applicable to large-scale reasoning about heap-based C programs. Namely, the novelty lies in the combination of: (i) automatically carrying out word and heap abstractions on input specifications, without requiring user input; and (ii) simultaneously, generating a full LCF-proof that these abstractions are sound. Previous work has either axiomatised the abstraction, or required the abstractions and associated proofs to be carried out manually. Using AutoCorres, one can carry out algorithmic verification at a high level of abstraction, while obtaining a machine-checked proof that the verification holds for the C source program, or even the compiled binary when chained with recent translation validation work [25].

本文的贡献是解决这两个问题，通过扩展AutoCorres的两个关键抽象，使其适用于基于堆的C程序的大规模推理。即，它的新颖性在于:(i)自动执行对输入规范的word和堆抽象，而不需要用户输入;同时，生成一个完整的lcf证明，证明这些抽象是合理的。以前的工作要么对抽象进行公理化，要么要求手动执行抽象和相关的证明。使用AutoCorres，人们可以在抽象的高级别上执行算法验证，同时获得C源程序的机器检查证明，甚至在与最近的翻译验证工作[25]连接时编译的二进制文件。
