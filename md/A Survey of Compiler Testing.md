# A Survey of Compiler Testing

Virtually any software running on a computer has been processed by a compiler or a compiler-like tool. Because compilers are such a crucial piece of infrastructure for building software, their correctness is of paramount importance. To validate and increase the correctness of compilers, significant research efforts have been devoted to testing compilers. This survey article provides a comprehensive summary of the current state-of-the-art of research on compiler testing. The survey covers different aspects of the compiler testing problem, including how to construct test programs, what test oracles to use for determining whether a compiler behaves correctly, how to execute compiler tests efficiently, and how to help compiler developers take action on bugs discovered by compiler testing. Moreover, we survey work that empirically studies the strengths and weaknesses of current compiler testing research and practice. Based on the discussion of existing work, we outline several open challenges that remain to be addressed in future work.

实际上，在计算机上运行的任何软件都已由编译器或类似编译器的工具处理。因为编译器是构建软件的关键基础设施，所以它们的正确性至关重要。为了验证和增加编译器的正确性，大量的研究工作一直致力于测试编译器。这篇调查文章全面总结了当前编译器测试研究的最新进展。该调查涵盖了编译器测试问题的不同方面，包括如何构建测试程序，使用什么测试神谕来确定编译器的行为是否正确，如何高效地执行编译器测试,以及如何帮助编译器开发人员对编译器测试发现的 bug 采取行动。此外，我们还调查了实证研究当前编译器测试研究和实践的优缺点的工作。根据对现有工作的讨论，我们概述了未来工作中仍有待解决的几个公开挑战。

## 1 INTRODUCTION

Compilers are important tools, because they are a central piece of infrastructure for building other software. Virtually every program that runs on a computer, ranging from operating systems over web browsers to small scripts written by end-users, has been processed by a compiler or a compilerlike tool. Because compilers are such a central piece of infrastructure, they are very widely distributed. For example, popular compilers of widespread programming languages, such as GCC for C/C++, are run by millions of users. Beyond these direct users of compilers, typically developers, much more people indirectly rely on compilers when executing compiled programs.

编译器是重要的工具，因为它们是构建其他软件的核心基础设施。实际上，在计算机上运行的每一个程序，从网络浏览器上的操作系统到最终用户编写的小脚本，都已经被编译器或类似编译器的工具处理过了。因为编译器是基础设施的核心部分，所以它们的分布非常广泛。例如，流行的广泛编程语言 (如 C/C + + 的 GCC) 的编译器由数百万用户运行。除了这些编译器的直接用户 (通常是开发人员) 之外，更多的人在执行编译程序时间接依赖编译器。

Even though considerable efforts have been made to improve the quality of compilers, similar to all other software, compilers still contain bugs [72, 103, 123]. A compiler bug can cause incorrect binary code to be generated from correct source code. Also, a single bug in a production compiler can propagate to any application built upon it and cause surprising and possibly harmful misbehavior. For example, a miscompilation bug in the Java 7 implementation caused several popular Apache projects to crash.1 Sometimes, compiler bugs may even be injected on purpose to compromise the security of compiled applications. For example, a malicious variant of Apple’s Xcode development environment contained a compiler “bug” that introduces a backdoor into every compiled application. 2 Such compiler backdoors can also exploit accidentally introduced bugs, as evidenced by work on compromising the Unix sudo tool via a publicly known bug in LLVM [105].

即使已经做出了相当大的努力来提高编译器的质量，类似于所有其他软件，编译器仍然包含 bug [72,103，123]。编译器错误可能导致从正确的源代码生成不正确的二进制代码。此外，生产编译器中的单个 bug 可以传播到任何构建在其上的应用程序，并导致令人惊讶且可能有害的不当行为。例如，Java 7 实现中的一个编译错误导致几个流行的 Apache 项目崩溃。有时，编译器错误甚至可能被故意注入，以损害编译应用程序的安全性。例如，苹果 Xcode 开发环境的恶意变体包含一个编译器 “bug”，它在每个编译的应用程序中引入了后门。这样的编译器后门也可以利用意外引入的错误，通过在 LLVM [105] 中公开已知的错误来危害 Unix sudo 工具的工作就证明了这一点。

Compiler bugs not only cause unintended behavior with possibly severe consequences, but also make software debugging more difficult. The reason is that developers can hardly determine whether a software failure is caused by the program they are developing or the compilers they are using [26]. For example, when a buggy compiler optimizes a correct program into an executable that has incorrect runtime behavior, it is unclear to the developer of the program what causes the unexpected behavior. Since application developers usually assume the misbehavior tends to be caused by bugs introduced by themselves, they may spend a long time to eventually realize that a compiler bug is the root cause.
