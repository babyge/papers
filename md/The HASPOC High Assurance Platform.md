# The HASPOC High Assurance Platform

## 7 Formal Verification Methodology

The formal verification of the HASPOC virtualization platform aims at establishing mathematically proven and machine checked guarantees of the isolation of guests in the system. The top level property we aim to show in the project is non interference: that no information can flow between guests exc ept through explicitly defined channels. This means in particular that guests cannot change the private data of other guests or the hypervisor (integrity or no exfiltration) and that they cannot observe the contents of these private resources (confidential ity or no infiltration), see [HALM].

HASPOC虚拟化平台的正式验证旨在建立在系统中隔离来宾的经过数学验证和机器检查的保证。在这个项目中，我们的最高目标是不干涉:除了通过明确定义的渠道，任何信息都不能在客人之间流动。这特别意味着，客户机不能更改其他客户机或hypervisor的私有数据(完整性或不泄漏)，它们不能观察这些私有资源的内容(机密性或不渗透)，参见[HALM]。

Formally, integrity is stated as a safety property property1 on execution traces of a system. Assume that Wi is the set of resources that guest i is allowed to modify according to the access policy governed by the hypervisor. Re sources in this setting cover not only memory cells but also registers and output signals. If a system fulfills the integrity property for guest i, then for all possible execution steps of this guest indeed only resources in Wi are modified (thus all other resources are unchanged) On the other hand confidentiality is a trace hyperproperty (relating different executions of the same system) concerning the resources Ri that guest i is allowed to read or write write2. Roughly speaking it says that for two starting states S1 and S2 where the contents of Ri are identical (but everything else might differ) if guest i executes the same code in both states, then after any number of steps the contents of Ri are mutually identical in the trace st arting from S1 and the trace starting from S2. That means that updates to the resources in Ri do not depend on anything that is not accessible to guest i, therefore no private data of others is leaked to guest i .

形式上，完整性被声明为系统执行轨迹上的安全属性property1。假设Wi是允许来宾i根据管理程序控制的访问策略修改的一组资源。此设置中的资源不仅包括内存单元，还包括寄存器和输出信号。如果一个系统满足客人我完整性属性,那么这个客人的所有可能的执行步骤实际上只有资源Wi修改(因此所有其他资源不变)另一方面保密是一个跟踪hyperproperty(涉及不同的执行相同的系统)有关资源国际扶轮客人我可以读或写写。粗略地说，对于两个初始状态S1和S2，其中Ri的内容相同(但其他内容可能不同)，如果guest i在这两种状态中执行相同的代码，那么在任意数量的步骤之后，在从S1开始的跟踪和从S2开始的跟踪中，Ri的内容都是相同的。这意味着对Ri中的资源的更新不依赖于来宾i不能访问的任何内容，因此不会将其他人的私有数据泄露给来宾i。

Naturally one has to show these propertie s for all guests in the system. In the formal proof that the HASPOC hypervisor exhibits them, several refinement steps are taken. Broadly, the first step employs a so called bisimulation based approach to ensure that the platform design resembles a system where non interference holds by construction. The second part of the proof focuses on the handler code and establishes the correctness of its binary implementation by means of (semi) automated code verification methods. The overall structure of the verific ation methodology is depicted in Fig 20.

自然，必须为系统中的所有来宾显示这些属性。在HASPOC hypervisor展示它们的正式证明中，采取了几个改进步骤。广泛地说，第一步采用了所谓的基于二等分的方法，以确保平台设计类似于一个不受施工干扰的系统。证明的第二部分着重于处理程序代码，并通过(半)自动化代码验证方法建立其二进制实现的正确性。验证方法的总体结构如图20所示。

### 7.1 Real Ideal Bisimulation

In general a simulation proof between two systems A and B is conducted to show that B is refining (implementing) A, or equivalently that A abstracts from (simulates) B. The two systems are usually coupled with a simulation relatio n sim between states of A and B. It is then proven by induction that for any computation of B starting in state b that is related to a state a of A by sim , there exists a simulating execution of A such that the resulting states b' and a' are again containe d in the simulation relation sim . Note that this means that there might be execution traces in A that are not exhibited by B, however all possible behavior of B is modeled by the abstract model A, which is called soundness of the simulation.

一般模拟证明a和B两个系统之间进行显示B是精炼(实现),或者说,一个抽象(模拟)B的两个系统之间通常加上sim仿真关系状态的a和B,然后用归纳法证明任何计算B从状态与状态相关的sim卡的,存在a的模拟执行，使得结果状态b'和a'再次包含在模拟关系sim中。注意，这意味着A中可能存在B没有显示的执行轨迹，但是B的所有可能行为都是由抽象模型A建模的，这被称为模拟的可靠性。

A bisimulation is a special case of simulation between two systems where both systems are simulating each other. That is, also for every computation of A one must show that there exists a simulating computation of B. Thus all possible behaviors of A are also implemented in B, which is called completeness of the simulation . In case A and B are deterministic systems whose computations only depend on the initial state, it is enough to show the simulation once, because for every pair of initial states a and b there is only o ne pair of corresponding traces in A and B.

双模是两个系统之间相互模拟的一种特殊情况。也就是说，对于A的每一次计算，都必须表明存在B的模拟计算，因此A的所有可能行为也都在B中实现，称为仿真的完整性。如果A和B是确定性系统，其计算只依赖于初始状态，那么展示一次模拟就足够了，因为对于每一对初始状态A和B，在A和B中只有一对对应的轨迹。

A typical example for a bisimulation relation is compiler correctness, e.g., between a high level language model A and its assembly implementation B. The relation in this case would link high level concepts with low level hardware components, e.g., high level variable values with the content of registers and memory cells, the high level code with the generated instructions in the code segment, as well as the current program rest or continuation of the high level p rogramming language semantics with the program counter of the executing processor. For soundness one needs to show that all the generated code in B implements some behavior of A, i.e., that a compiler only generates code that is covered by the original program semantics in A. On the other hand one would like the compiler to generate complete code, e.g., if a program exhibits several entry points, code should be generated for all possible execution traces and not just a subset of those. If the bisimulation is proven to hold for all execution traces of A and B, any safety property shown for A also holds on all traces in the implementation B (in a translated from). In addition, trace hyperproperties proven about A can be transferred to B as well. A bisimulation proof in this example could be performed for a particular pair of programs from A and compiled programs from B, by structural induction over the call graph of both, showing that the compiler correctness relation holds in corresponding, entry, branch, input/output, and exit nodes. Alternatively, one could target the compiler itself and proof the bisimulation for all programs and their compiled versions, by arguing over the code generation and memory allocation functions of the compiler which define the bisi mulation relation in a general way. Doing this for an optimizing compiler is complicated and usually requires several refinement steps. Therefore for the verification of machine code in HASPOC we stick to the first method.

bisimulation关系一个典型的例子是编译器正确性,如高级语言模型及其之间的装配实现b。在这种情况下将链接的关系高水平与低水平的硬件组件的概念,例如,高水平变量值寄存器的内容和记忆细胞,高水平的代码与生成的指令代码段,以及当前程序的rest或高级编程语言语义与执行处理器的程序计数器的延续。为了保证可靠性，我们需要显示B中生成的所有代码都实现了A的某些行为，即。,只一个编译器生成的代码覆盖的原始程序语义在a。另一方面希望编译器生成完整的代码,例如,如果一个程序展示多个入口点,生成的代码应该是所有可能的执行踪迹,而不仅仅是其中的一个子集。如果双并行被证明对A和B的所有执行轨迹都成立，那么为A显示的任何安全属性也会在实现B中的所有轨迹上成立(A翻译成from)。此外，A证明的跟踪超属性也可以转移到B。在本例中，通过对A和B的调用图进行结构归纳，可以对A的特定程序和B的编译程序进行双模证明，表明编译器的正确性关系保持在相应的、入口、分支、输入/输出和出口节点上。或者，我们可以针对编译器本身，通过对编译器的代码生成和内存分配函数的争论来证明所有程序及其编译版本的对偶化，这些编译器定义了一般的对偶化关系。对于优化编译器来说，这样做是复杂的，通常需要几个改进步骤。因此，对于HASPOC中的机器码验证，我们坚持使用第一种方法。

#### 7.1.1 Ideal vs. Real Model

The idea of the real ideal approach to proving information flow properties now is to formulate an idealized abstract model of the system which by construction has the desired properties (e.g., non interference). The main idea of virtualization (and isolation) is to provide an illusion to the guest processes that they are running on the machine alone. Each guest owns a virtual machine which in principle completely isolated from the others'.

现在证明信息流特性的真正理想方法的思想是建立一个理想化的系统抽象模型，该模型通过构造具有期望的特性(例如，不干涉)。虚拟化(和隔离)的主要思想是为客户进程提供一种假象，即它们是单独在机器上运行的。每个客户都拥有一个虚拟机，原则上它与其他客户的虚拟机完全隔离。

We pick up this idea and model the ideal system as a number of separate virtual machines, which are reduced versions of the original ARMv8 processor cores. Specifically, these machines can only run in EL1 and EL0 and there is only one stage of address translation. There is only a subset of the platform's interrupts available to each guest and the memory allocated to each guest has a smaller size than the complete physical memor y. Similarly, peripherals are only connected to machines that are allowed to use them. The communication mechanism between the guests provided by the hypervisor can be modeled abstractly by a message passing protocol using device like unidirectional messa ge channels between the virtual guest machines. For other services provided by the hypervisor or the ARM Trusted Firmware code running in EL3, abstract data structures may be added to the ideal model which can be affected by the guest using hypercalls/SMCs . These are represented as atomic transitions of the model. If two guests were running on the same core, they would be executed in an alternating fashion, controlled by a dedicated scheduler/timer, however in the HASPOC setting cores are owned exclusively . Nevertheless, there is a global scheduler which interleaves the parallel execution of the cores in a sequential way. Note that apart from the shared memory used to implement the communication between guests, the guest operating systems are free to config ure their private memory as they wish. This means that their virtual memories exhibit all properties of the weakly consistent memory model of ARM (see 7.3) and sequential consistency cannot be assumed for the execution of the guests. Especially if one gues t is running on several cores its virtual machine is a multicore processor with a weakly consistent memory.

我们采用了这个想法，并将理想的系统建模为许多独立的虚拟机，这些虚拟机是原始ARMv8处理器内核的简化版本。具体地说，这些机器只能在EL1和EL0中运行，并且只有一个地址转换阶段。对于每个客户机，只有平台中断的子集可用，并且分配给每个客户机的内存比整个物理内存的大小要小。类似地，外设只连接到允许使用它们的机器上。虚拟机监控程序提供的来宾之间的通信机制可以通过消息传递协议抽象建模，消息传递协议使用虚拟来宾机之间的单向消息通道之类的设备。对于由hypervisor或在EL3中运行的ARM受信任固件代码提供的其他服务，可以将抽象数据结构添加到理想模型中，该模型可以通过hypercalls/SMCs受到来宾操作系统的影响。它们表示为模型的原子转换。如果两个客户机在同一个核心上运行，它们将以交替的方式执行，由专用的调度器/定时器控制，然而在HASPOC设置中核心是独占的。然而，有一个全局调度器，它以顺序的方式交错执行内核的并行。请注意，除了用于实现来宾之间通信的共享内存之外，来宾操作系统还可以随意配置它们的私有内存。这意味着它们的虚拟内存展示了ARM弱一致性内存模型的所有属性(见7.3)，并且不能假定来宾的执行具有顺序一致性。特别是当一个客户运行在几个核上时，它的虚拟机是一个具有弱一致性内存的多核处理器。

One the other hand there is the model of the “real” system which represents the HASPOC platform on the design level. The system resembles the actual physical machine with all execution levels and the second stage address translation for the guests. Similarly the interrupt controller and system MMU become visible and the interrupts to the gu ests are routed through the hypervisor. Hypercalls and SMCs are not executed atomically but according to a transition system that resembles their C and assembly implementation. The interleaving of hypervisor and guest execution on each core becomes explici t including the saving and restoring of the virtual machine contexts. Moreover there is now only one weakly consistent memory shared between all guests. However the sequentially consistent hypervisor memory is separate from this memory and shared between t he hypervisor threads. The implementation counterparts of the abstract data structures from the ideal model are located in this part of memory using virtual addresses. Figure 2 1 shows an example of the real and ideal model.

另一方面是“真实”系统的模型，它在设计层上代表了HASPOC平台。该系统类似于实际的物理机器，具有所有的执行级别和客户的第二阶段地址转换。类似地，中断控制器和系统MMU变得可见，对来宾的中断将通过hypervisor路由。超调用和smc不是自动执行的，而是根据类似于它们的C和汇编实现的转换系统执行的。每个核心上的虚拟机监控程序和客户执行的交错变得显式，包括虚拟机上下文的保存和恢复。此外，现在只有一个弱一致的内存在所有来宾之间共享。但是顺序一致的虚拟机监控程序内存与此内存是分开的，并在虚拟机监控程序线程之间共享。理想模型中抽象数据结构的实现对等物使用虚拟地址位于这部分内存中。图21显示了真实和理想模型的示例。

Once the models are fixed, one p erforms a bisimulation proof between the ideal model and the real model in order to show that they behave equivalently (see Fig 21). Proving simply a refinement from the ideal to the real model (i.e., a simulation between ideal and real model) is not enoug h here, because confidentiality is a hyperproperty. In order to transfer confidentiality from the ideal model (where it holds trivially by construction) to the real model we need completeness of the simulation, i.e., that both traces in the ideal model hav e a counterpart in the real model. Then the simulation relation which holds between the corresponding resulting states can be used to establish that the accessible state of the executing guest is still identical. The bisimulation relation for this proof is quite straight forward. All the components of the ideal model need to be mapped to counter parts in the real model. This are first and formost the (intermediate physical) memory regions and the register state(s) of each guest. They are mapped to the actua l physical memory regions and register states to either the actual register on a given core, or the saved guest context for this core, depending on whether hypervisor or guest are currently running. The contents of abstract message channels are mapped to t he shared IGC memory regions. Similarly abstract hypervisor data structures that may be visible in the ideal model are mapped down to their implementation in hypervisor memory. Devices are mapped one to one between the ideal and real models. If there is a part of the interrupt controller visible in the ideal model and configurable by the guests, it has to be coupled accordingly with the actual IGC hardware as represented in the real model.

一旦模型固定，就可以在理想模型和真实模型之间进行双模证明，以表明它们的行为是相等的(见图21)。简单地证明了从理想到真实模型的细化(即。这里还不够，因为机密性是一种超属性。为了将机密性从理想模型(它通过构造而保持)转移到真实模型，我们需要仿真的完整性，即。，即理想模型中的这两种轨迹在实际模型中都有对应的轨迹。然后，利用结果状态之间的模拟关系，可以确定执行来宾的可访问状态仍然相同。这个证明的二值化关系是相当直接的。理想模型的所有组件都需要映射到实际模型中的对应部分。这首先是每个客户机的(中间物理)内存区域和寄存器状态。它们被映射到实际的物理内存区域，并将注册状态映射到给定核心上的实际注册或该核心保存的来宾上下文，具体取决于当前运行的是hypervisor还是guest。抽象消息通道的内容被映射到共享的IGC内存区域。类似地，在理想模型中可见的虚拟机监控程序抽象数据结构被映射到虚拟机监控程序内存中的实现。设备在理想模型和真实模型之间一一对应。如果在理想模型中有一部分中断控制器是可见的，并且可以由来宾进行配置，那么它就必须与实际模型中所表示的IGC硬件相耦合。

It should be noted that parts of the real model, e.g., the second st age MMU, the SMMU, (parts of) the interrupt controller, and parts of the hypervisor memory are not covered by the bisimulation relation. This makes sense since these resources are either fixed and crucial in establishing the idealiz ed picture of the system or they are internal hypervisor structures that should not influence the behavior of guests and can thus be hidden from the outside view. However an invariant guaranteeing the isolation property must be proven on the real model along with the bisimulation Note also, that the real model is still quite abstract in that it separates the hypervisor memory from the guests. In order to justify it formally, another bisimulation theorem is established with the hypervisor code running in the actual weak memory mod el that is shared between all cores. This theorem needs to argue about the restrictions we place on the hypervisor code that allow establishing sequential consistency, e.g., using only cacheable memory, not modifying the hypervisor page tables, using a loc king discipline on shared hypervisor data structures to avoid data races, etc.

需要注意的是，实际模型的一些部分，例如第二阶段的MMU、SMMU、中断控制器的(部分)和hypervisor内存的一部分，都不包括在二值化关系中。这是有意义的，因为这些资源要么是固定的，并且在建立理想的系统图景时至关重要，要么它们是内部管理程序结构，不应该影响来宾的行为，因此可以从外部视图中隐藏起来。但是，必须在实际模型上证明保证隔离属性的不变量，同时还要说明，实际模型仍然非常抽象，因为它将hypervisor内存与来宾操作系统分隔开来。为了正式地证明它，在虚拟机监控程序代码运行的实际弱内存模块中建立了另一个二项式定理，该模块在所有核之间共享。这个定理需要讨论我们在虚拟机监控程序代码上设置的允许建立顺序一致性的限制，例如，只使用可缓存内存，不修改虚拟机监控程序页表，在共享的虚拟机监控程序数据结构上使用锁定规则以避免数据竞争，等等。

However, proving this theorem is currently outside of the scope of HASPOC and is being studied in a related project “PROSPER” [PROSPER]. In what follows we will focus on the rea l ideal bisimulation proof which splits into four parts.

然而，证明这个定理目前已经超出了HASPOC的范围，一个相关的项目“PROSPER”[PROSPER]正在进行研究。在接下来的内容中，我们将重点讨论实理想二分证明，它分为四个部分。

#### 7.1.2 Initialization/Boot

The bisimulation concerning the hypervisor ex ecution starts in an initial ideal and a real state where the bisimulation already holds. In order to obtain this initial property we need to argue about the boot code and the initialization code of the hypervisor. After the execution of this code, executi on must arrive in a real state that is bisimilar to the initial state of the ideal model. This means that the guests are set up and ready to boot. Moreover the second stage of the address translation for EL1 and EL0 must be configured to guarantee the isol ation of the guests and the interception of accesses to the inter guest communication control structure. Similarly the SMMU and interrupt controller are set up to conform to the configuration of peripherals in the hypervisor configuration file. Finally all data structures supporting hypercalls and SMCs are initialized correctly. We refer to these conditions as the implementation invariant.

与hypervisor执行有关的双值化从一开始的理想状态和已经存在双值化的实际状态开始。为了获得这个初始属性，我们需要讨论系统管理程序的引导代码和初始化代码。在执行这段代码之后，执行必须到达与理想模型初始状态相对比的真实状态。这意味着客户机已经设置好并准备启动。此外，必须配置EL1和EL0的地址转换的第二阶段，以保证来宾的隔离和对来宾间通信控制结构的访问的拦截。类似地，SMMU和中断控制器的设置与hypervisor配置文件中的外设配置一致。最后，所有支持超调用和smc的数据结构被正确初始化。我们将这些条件称为实现不变量。

This setting is implemented mainly mainly by the hypervisor initialization code. In order to run the hypervisor it first has to be loaded into DRAM and called at its entry point. This is the task of the secure bot loader of the HASPOC platform. Before that the boot loader also needs to configure low level peripherals of the SoC that are necessary to execute according to the ISA specification. This includes activating timers and clocks, DRAM, caches, as well as configuring power management and the TrustZone controller that determines which regions of memory belong to the Secure World. Furthermore, the boot loader needs to install Secure World services and interrupt handlers as well as copy the guest images and hypervisor configuration file. The authenticity of all files loaded by the boot code need to be validated cryptographically.

该设置主要由hypervisor初始化代码实现。为了运行hypervisor，首先必须将其加载到DRAM中并在其入口点调用它。这是HASPOC平台的安全bot加载程序的任务。在此之前，引导加载程序还需要配置SoC的低级别外围设备，这些外围设备需要根据ISA规范执行。这包括激活计时器和时钟、DRAM、缓存，以及配置电源管理和TrustZone控制器，该控制器决定哪些内存区域属于安全世界。此外，引导加载程序需要安装安全的World服务和中断处理程序，并复制客户映像和hypervisor配置文件。启动代码加载的所有文件的真实性需要通过加密方式进行验证。

To verify these requirements on the initialization of the HASPOC platform we mainly employ sequential code verification. The details will be discussed below. Proving the soundness of the approach is easier than for the runtime phase, because all the code is executed on the primary processor core while all secondary cores are suspended. Therefore we can reduce the weakly consistent concurrent model to a sequential setting where no other actors in the system interfere. Again, proving this theorem is out of the scope of the HASPOC project.

为了在HASPOC平台的初始化中验证这些需求，我们主要使用顺序代码验证。细节将在下面讨论。证明这种方法的可靠性要比在运行时阶段容易，因为所有代码都在主处理器核心上执行，而所有辅助核心都挂起。因此，我们可以将弱一致性并发模型简化为顺序设置，在这种情况下，系统中没有其他参与者进行干扰。同样，证明这个定理也超出了HASPOC项目的范围。

#### 7.1.3 Guest/Switch Lemma

The verification of the bisimulation for the runtime phase of the platform covers three cases: execution of a guest process in its virtualized execution environment, switching from the guest into the hypervisor, running the hypervisor handlers and SMCs. The first two are handled by the so called “Guest/Switch Lemma” which mainly depends on the ARMv8 architecture and the configuration of the platform obtained from the initialization phase.

平台运行时阶段的双映射验证包括三种情况:在其虚拟化执行环境中执行来宾进程、从来宾操作系统切换到hypervisor、运行hypervisor处理程序和SMCs。前两个是由所谓的“来宾/交换机引理”处理的，它主要依赖于ARMv8架构和从初始化阶段获得的平台配置。

For every possible step of the guest process we need to show that the step preserves the bisimulation relation between the real and ideal model, i.e., it behaves as if it was running on its own isolated machine. In particular this includes to show that it can only access its own memory and other parts of the system stay unchanged (integrity), and that it cannot obtain leaked information from other guest or the hypervisor (confidentiality). If any of this were possible, the bisimulation relation could not be established since in the ideal model guest steps cannot affe ct or read from foreign resources directly. To prove the properties we require a detailed model of the ARMv8 architecture which covers all features of the architecture that a guest running in EL1 or EL0 could abuse to break these properties. Then a big cas e split over all possible transitions of this model is conducted. Guests in this context are also peripherals which can access the memory using DMA.

对于客户过程的每一个可能的步骤，我们都需要证明该步骤保持了真实模型和理想模型之间的二值化关系，即。，它就像在自己独立的机器上运行一样。特别地，这包括表明它只能访问自己的内存，系统的其他部分保持不变(完整性)，并且它不能从其他来宾或管理程序获得泄漏的信息(机密性)。如果这些都是可能的，那么就不能建立二值化关系，因为在理想的模型中，客户步骤不能直接影响外部资源或从外部资源读取数据。为了证明这些属性，我们需要一个ARMv8架构的详细模型，它涵盖了架构的所有特性，运行在EL1或EL0中的客户可能会滥用这些特性来破坏这些特性。然后对该模型所有可能的转换进行了一个大的案例拆分。在这个上下文中，来宾也是可以使用DMA访问内存的外设。

The main arguments that integrity and confidentiality are preserved by guest execution steps is the configu ration of the second stage address translation and the SMMU, guaranteeing memory isolation between hypervisor and guests. Moreover, the correct setup and virtualization of the interrupt controller ensures that guests cannot send interrupts arbitrarily to o ther guests or intercept interrupts not meant for them. As noted above these properties are guaranteed by the implementation invariant that has to be maintained by all steps of the system. Additionally the hardware virtualization support plays an important role to ensure that guests can only execute EL1 and EL0 operations.

客户机执行步骤保持完整性和机密性的主要理由是第二阶段地址转换和SMMU的配置，确保hypervisor和客户机之间的内存隔离。此外，中断控制器的正确设置和虚拟化可以确保客户机不能任意地向其他客户机发送中断，也不能拦截不属于它们的中断。如上所述，这些属性由实现不变式保证，系统的所有步骤都必须维护该不变式。此外，硬件虚拟化支持在确保客户机只能执行EL1和EL0操作方面发挥了重要作用。

As the model of the complete platform is highly complex, we follow a decompositional approach to prove the non interference properties on the architecture. We decompose the model into sma ller automata that model the execution of the instruction core, MMU, SMMU, peripherals, the interrupt distributer, and the weakly consiste nt shared memory. These automata are communicating with each other via message passing and their execution is interlea ved arbitrarily according to an external oracle. Also single components (e.g., the shared memory) can be non deterministic automata and be decomposed further.

由于完整平台的模型非常复杂，我们采用分解的方法来证明架构上的不干涉特性。我们将模型分解成更小的自动机，这些自动机对指令核心、MMU、SMMU、外设、中断分发器和弱一致性共享内存的执行进行建模。这些自动机通过消息传递彼此通信，它们的执行根据外部oracle任意交错。同样，单个组件(例如，共享内存)可以是不确定的自动机并被进一步分解。

This decomposition allows us to easily extend the hardware model without needing to re verify the entire non interference theorem for the architecture. Also the proof itself becomes more manageable, since for instance the memory isolation properties are independent of the instruction definition in the processor core component. Furthermore, the decompo sition opens the door for automating parts of the proof. We are developing a tool which automatically processes the definition of the instruction semantics for the core component, analyses the possible information flow between core registers, and proves in tegrity and confidentiality properties in a mechanized fashion. For example, there are a lot of system registers in the core that cannot be accessed in EL1 and EL0. The tool then detects that these registers belong to the confidential part of the state and returns a soundness checked theorem that indeed a guest can never read or write them.

这种分解允许我们很容易地扩展硬件模型，而不需要重新验证整个架构的不干涉定理。证明本身也变得更易于管理，因为例如，内存隔离属性独立于处理器核心组件中的指令定义。此外，分解打开了实现证明部分自动化的大门。我们正在开发一种工具，它可以自动处理核心组件指令语义的定义，分析核心寄存器之间可能的信息流，并以一种机械化的方式证明完整性和机密性。例如，在EL1和EL0中无法访问核心中的许多系统寄存器。然后，该工具检测到这些寄存器属于状态的机密部分，并返回一个可靠性检查定理，即访客确实永远不能读取或写入它们。

As mentioned before, the memory isolation is mainly guaranteed by the configuration of the (S)MMU. A separate proof on the (S)MMU component can in deed show, that if s econd stage page tables are set up accordingly it will never generate a memory request that will access a protected region of memory, no matter what requests are sent to it from guests/peripherals.

如前所述，内存隔离主要由MMU的配置来保证。在MMU组件上的一个单独的证明实际上可以表明，如果第二阶段页表被相应地设置，它将永远不会生成一个访问受保护内存区域的内存请求，而不管从来宾/外设向它发送了什么请求。

Special care has to be taken for proving the bisimulation between the virtual memory components and the real shared memory. For instance, all cores store data in the same second level cache. While the set up of the page tables guarantees memory isolation also for the caches, i.e., programs cannot directly read data corresponding to addresses for which they do not have permissions, it can be observed by an attacker (via timing analysis or uncacheable aliasing) whether its own data is stored in the cache or not.

必须特别注意证明虚拟内存组件和实际共享内存之间的双映射。例如，所有核心都将数据存储在同一二级缓存中。虽然页表的设置也保证了缓存的内存隔离，即。，程序不能直接读取对应于它们没有权限的地址的数据，它自己的数据是否存储在缓存中，可以被攻击者观察到(通过时间分析或非缓存的别名)。


