# Survey and Analysis of Kernel and Userspace Tracers on Linux: Design, Implementation, and Overhead

As applications and operating systems are becoming more complex, the last decade has seen the rise of many tracing tools all across the software stack. This article presents a hands-on comparison of modern tracers on Linux systems, both in user space and kernel space. The authors implement microbenchmarks that not only quantify the overhead of different tracers, but also sample fine-grained metrics that unveil insights into the tracers’ internals and show the cause of each tracer’s overhead. Internal design choices and implementation particularities are discussed, which helps us to understand the challenges of developing tracers. Furthermore, this analysis aims to help users choose and configure their tracers based on their specific requirements to reduce their overhead and get the most of out of them.

随着应用程序和操作系统变得越来越复杂，在过去的十年里，软件堆栈中出现了许多跟踪工具。这篇文章介绍了 Linux 系统上的现代示踪剂的实际比较，包括用户空间和内核空间。作者实施了微基准，不仅量化了不同示踪剂的开销，还抽样了细粒度的指标，揭示了对示踪剂内部的洞察，并显示了每个示踪剂开销的原因。讨论了内部设计选择和实施的特殊性，这有助于我们理解开发示踪剂的挑战。此外，这种分析旨在帮助用户根据他们的具体要求选择和配置他们的示踪剂，以减少他们的开销，并充分利用他们。

## 1 INTRODUCTION

Tracing has proved itself to be a robust and efficient approach to debugging and reverse engineering complex systems. The past decade has seen the rise of many tracers across all layers of the software stack, and even at the hardware level (Intel Corporation 2016; Sharma and Dagenais 2016a). Some applications, such as Google Chrome, even provide tracers natively integrated within the product itself. Fundamentally, tracing is a sophisticated form of logging where a software component, called the tracer, provides a framework that implements efficient and configurable logging. The most common use of logging by developers is done via the printf() function (or an equivalent), although this method is largely inefficient and limited. Tracers provide more flexible and robust approaches that can be easily maintained over time and usually add little overhead. Tracing is common in user applications, but is also widely used in the Linux kernel, which provides multiple tracing infrastructures.With complex online distributed systems, tracing becomes an efficient way of debugging problems whenever they arise. Although it is a problem that is often underestimated, the need for efficient and low-impact tracers is increasing, especially with modern parallel heterogeneous systems of ever-increasing complexity. The Linux kernel contains over 1,000 tracepoints and the volume of events that can be generated at runtime reinforces the need for low-impact tracers. In this article, we focus on the overhead that different tracers add to the traced applications, both at the user and kernel levels, on Linux systems. We start by establishing the nomenclature used in this article, and categorizing the many tools that have been gathered under the term “tracer.”We explain the differences between them from the user point of view, we summarize the mechanisms used by each to perform its tasks, and we show key design and implementation decisions for each when relevant. We propose a microbenchmark that aims at providing reliable low-level and fine-grained metrics for an in-depth analysis and comparison.

跟踪已被证明是调试和逆向工程复杂系统的健壮和有效的方法。在过去的十年中，软件栈的所有层甚至硬件层都出现了许多跟踪器(Intel Corporation 2016;Sharma和Dagenais 2016a)。一些应用程序，如谷歌Chrome，甚至提供了与产品本身集成的跟踪程序。从根本上说，跟踪是一种复杂的日志记录形式，其中一个称为跟踪器的软件组件提供了一个实现高效且可配置的日志记录的框架。开发人员最常用的日志记录方法是通过printf()函数(或类似的函数)来完成的，尽管这种方法的效率很低，而且局限性很大。跟踪器提供了更灵活、更健壮的方法，可以随着时间的推移轻松地进行维护，并且通常只增加很少的开销。跟踪在用户应用程序中很常见，但是在Linux内核中也被广泛使用，Linux内核提供了多个跟踪基础设施。对于复杂的在线分布式系统，跟踪成为一种有效的调试问题的方法。虽然这是一个经常被低估的问题，但对有效和低影响示踪剂的需求正在增加，特别是在复杂程度不断增加的现代并行异构系统中。Linux内核包含超过1,000个跟踪点，运行时可以生成的事件的数量增加了对低影响跟踪器的需求。在本文中，我们将重点讨论在Linux系统上的用户级和内核级，不同的跟踪程序给跟踪应用程序增加的开销。我们首先建立本文中使用的术语，并将收集到的许多工具归类为“跟踪器”。“我们从用户的角度来解释它们之间的区别，我们总结了它们执行任务的机制，并在相关的时候展示了它们的关键设计和实现决策。”我们提出了一个微基准，旨在为深入分析和比较提供可靠的低级别和细粒度度量。

In this article, we highlight the performance and the footprint of multiple tracers, as well as their underlying infrastructure. Many commercial and broadly known tools rely on the tracing infrastructure variants studied here, and thus the overhead measured directly applies. The contribution of this article is a deep dive into the design principles of modern tracers on Linux. This article tackles the problem of comparing tracers by measuring fine-grained and low-level performance metrics, so that the design choices made by the tracer developers, as well as the implementation and coding decisions, are taken into consideration when assessing the impact of a tracing tool on the traced system. Moreover, the contribution also encompasses a methodology for low-level benchmarking that unravels the real behavior of tracers, instead of using platform and micro-architecture emulators.

在本文中，我们将重点介绍多个跟踪程序的性能和占用空间，以及它们的底层基础设施。许多商业和广泛了解的工具依赖于本文所研究的跟踪基础结构变体，因此直接应用所测量的开销。本文的贡献在于深入探讨了Linux上现代跟踪程序的设计原则。本文通过度量细粒度和低级性能指标来处理比较跟踪程序的问题，以便在评估跟踪工具对跟踪系统的影响时，考虑跟踪程序开发人员所做的设计选择以及实现和编码决策。此外，本文的贡献还包括了一种用于低级基准测试的方法，它揭示了跟踪程序的真实行为，而不是使用平台和微体系结构模拟器。

The rest of the article is structured as follows: Section 2 goes over previous work on tracers benchmarks, Section 3 includes a reminder of key concepts required to understand the work presented and sets up the nomenclature used in this article, Section 4 explains the mechanisms used in tracing, Section 5 introduces the tracers and explains their internals when relevant, Section 6 explains the benchmarks, Section 7 shows the results of this work, and Section 8 concludes.

本文的其余部分的结构如下:第二节超过先前的工作追踪基准,第三节包括提醒我们了解工作所需的关键概念,建立了本文中使用的术语,第四节解释了用于跟踪机制,第五部分介绍了示踪剂并解释其内部相关时,第六节解释了基准,第七节显示了这项工作的结果,和8节总结道。

## 2 PREVIOUS WORK

Bitzes and Nowak (2014) studied the overhead of sampling using performance counters. However, their studies don’t address tracing in general. They also only focus on the approaches for collecting hardware counters’ data and their performance overhead, rather than covering the internals of the tracers or design and implementation choices. Sivakumar and Sundar Rajan (2010) measured the impact of the LTTng tracer, both in user and kernel space. The authors ran multiple known, general benchmarks and reported the overhead that the tracer added. This approach helps to estimate the impact that LTTng may have on specific workloads but doesn’t quantify in detail the cost of the instrumentation or the cause of the overhead. Mihajlović et al. (2014) discuss their work to enable hardware tracing in virtual environments by modifying the ARM ISA emulation and show the overhead added by their approach. While the approach it presents is interesting, their approach relies on dynamic tracing, which is a specific approach to tracing. Furthermore, it doesn’t cover or benchmark the fundamentalwork of tracers. Furthermore, no detailed comparison with other tracers is presented. Moore et al. (2001) reviewed performance analysis tools for MPI application. While they cover two of the tracers of this article, the work focuses primarily on the MPI framework, and doesn’t address kernel space tracing. The objective of the work also differs in that fundamental design choices of tracers with different scopes aren’t covered. In Ghods (2016), the author explains and analyzes the internals of the Perf tool, mainly for sampling performance hardware counters. This work doesn’t cover comparisons with other tracing tools. The work of Desnoyers (2009) reports benchmarking results for LTTng and other tracers, albeit only showing the latency of recording an event, without presenting a detailed comparison with other tracers.

Bitzes和Nowak(2014)研究了使用性能计数器进行抽样的开销。然而，他们的研究并没有涉及一般的追踪。它们还只关注收集硬件计数器的数据及其性能开销的方法，而不涉及跟踪器或设计和实现选择的内部内容。Sivakumar和Sundar Rajan(2010)测量了LTTng跟踪器在用户和内核空间的影响。作者运行了多个已知的通用基准测试，并报告了跟踪程序增加的开销。这种方法有助于估计LTTng可能对特定工作负载的影响，但不能详细量化工具的成本或开销的原因。Mihajlovićet al。(2014)讨论他们的工作,使硬件跟踪在虚拟环境中通过修改手臂ISA仿真和显示他们的方法所增加的开销。虽然它提供的方法很有趣，但是它们的方法依赖于动态跟踪，这是一种特定的跟踪方法。此外，它没有覆盖或基准示踪剂的基本工作。此外，没有与其他示踪剂进行详细的比较。Moore等人(2001)综述了用于MPI的性能分析工具。虽然它们涵盖了本文的两个跟踪程序，但主要关注的是MPI框架，而不是内核空间跟踪。这项工作的目标也不同，因为它没有涉及不同范围的跟踪器的基本设计选择。在Ghods(2016)中，作者解释并分析了Perf工具的内部机制，主要用于采样性能硬件计数器。这项工作不包括与其他跟踪工具的比较。Desnoyers(2009)的工作报告了LTTng和其他示踪剂的基准测试结果，尽管只显示了记录事件的延迟，并没有与其他示踪剂进行详细的比较。

The infrastructures and frameworks presented in this article are often the basis for other commercial and more broadly known monitoring and performance tools. For instance, the work by Gregg (2017) makes extensive use of Perf and eBPF. Flamegraphs are often generated by profiling applications using Perf, although it is a profiler rather than a tracer. Another example is SysDig, which uses the tracepoint infrastructure to extract information from the kernel.

本文中介绍的基础设施和框架通常是其他商业和更广泛了解的监视和性能工具的基础。例如，Gregg(2017)的工作中大量使用了Perf和eBPF。火焰图通常由使用Perf的剖析应用程序生成，尽管它是剖析器而不是跟踪器。另一个例子是SysDig，它使用跟踪点基础结构从内核中提取信息。

# 3 DEFINITIONS AND NOMENCLATURE

## 3.1 Definitions

This section serves as a reminder of some common terms in the world of tracing that are essential for understanding the rest of the article.
Tracepoint. A tracepoint is a statement placed directly in the code of an application that provides a hook to invoke a probe. A tracepoint generally provides a way in which it can be enabled or disabled dynamically.
Probe. A probe is a function that is hooked to a tracepoint and is called whenever the tracepoint is encountered at runtime (if enabled). A probe usually performs a custom task and is either implemented by the tracer or by the user. Typically, a probe needs to be as small and fast as possible, to add as little overhead as possible and reduce the perturbation to the system.
Event. An event marks the encounter of a tracepoint at runtime. Depending on the kind of tracing, the event can have a logical meaning, such as a context switch, or can simply represent a location in the code, such as a function entry or exit. An event is punctual and has no duration, and is usually annotated with a timestamp.
Payload. An event typically holds a payload, which is additional information related to the event. For instance, the payload of a context switch may contain the identifiers of the two tasks involved.
Ring Buffer. A data structure that serves as a placeholder for events. When an event is recorded at runtime, the tracer’s probe is invoked. The probe records the encountered event by placing it in memory in the ring buffer (producer). At a later time, a consumer can read the contents of the ring buffer and report them to the user. When the data structure is full, the incoming events may either replace the oldest events (in a ringlike fashion) or they may be discarded until some events have been consumed from the buffer.
Atomic Operation. An atomic operation has the characteristic of being indivisible, which implies that intermediate values or intermediate states are invisible to concurrent operations. Atomic operations usually require support from the hardware or the operating system, and great care must be taken by the developer to guarantee atomicity. For instance, on x86 architectures, a mov instruction isn’t guaranteed to be atomic unless its operands are cache-aligned. Consider the case where one of the operands is stored across two pages: the mov instruction will require access to different pages (and potentially cause virtual address translations), making the operation divisible and non-atomic, as an intermediate unstable value can be visible if the operand is accessed by another instruction between these steps.

本节将提醒您一些常见的跟踪术语，这些术语对于理解本文的其余部分非常重要。

Tracepoint。跟踪点是直接放在应用程序代码中的语句，它提供了一个钩子来调用探测。跟踪点通常提供动态启用或禁用跟踪点的方法。

调查。探测是一个连接到跟踪点的函数，在运行时遇到跟踪点时调用它(如果启用)。探测通常执行自定义任务，由跟踪程序或用户实现。通常，探测器需要尽可能小和快，以增加尽可能少的开销并减少对系统的干扰。

事件。事件标记运行时遇到的跟踪点。根据跟踪的类型，事件可以具有逻辑意义，例如上下文切换，也可以简单地表示代码中的位置，例如函数入口或出口。事件是准时的，没有持续时间，通常使用时间戳进行注释。

有效载荷。事件通常包含一个有效负载，它是与事件相关的附加信息。例如，上下文切换的有效负载可能包含所涉及的两个任务的标识符。

环形缓冲区。用作事件占位符的数据结构。在运行时记录事件时，将调用跟踪器的探测器。探测器通过将遇到的事件放置在环形缓冲区 (生产者) 的内存中来记录它。稍后，消费者可以读取环形缓冲区的内容并向用户报告。当数据结构已满时，传入的事件可能会取代最旧的事件 (以类似的方式)，或者它们可能会被丢弃，直到从缓冲区中消耗了一些事件。

原子操作。原子操作具有不可分割的特性，这意味着中间值或中间状态对并发操作是不可见的。原子操作通常需要硬件或操作系统的支持，开发人员必须非常小心，以保证原子性。例如，在 x86 体系结构上，除非 mov 指令的操作数与缓存对齐，否则它不能保证是原子的。考虑其中一个操作数跨两页存储的情况: mov 指令将需要访问不同的页 (并可能导致虚拟地址翻译), 如果操作数在这些步骤之间被另一个指令访问，则使操作可分和非原子，作为中间不稳定值可以是可见的。

## 3.2 Nomenclature

术语

We previously defined a tracepoint as a location in an application where a probe can be hooked. This section starts by introducing the different mechanisms used for probe callback, as well as their implementations. A mechanism is a known theoretical approach as to how a callback can be implemented, but the actual implementation is left to the tracing infrastructure. For instance, a trampoline is a mechanism that allows instrumentation at runtime, but the actual implementation of the trampoline is left to a tracing infrastructure such as DynInst or Kprobes. Similarly, a tool can support multiple mechanisms and allow its users to configure the mechanism to be used, depending on their needs. Tracers can then be built atop these technologies to leverage their callback mechanisms, thus outsourcing this crucial part. Tracers can be built to support multiple callback mechanisms, for better flexibility and feature offerings. In summary, a tracer can use one or many callback implementations, which in turn implement one or many mechanisms. For instance, LTTng can use either TRACE_EVENT or Kprobes, and Kprobes can use either a trap or a trampoline.

我们之前将跟踪点定义为应用程序中可以连接探针的位置。本节首先介绍用于探测回调的不同机制及其实现。机制是关于如何实现回调的一种已知的理论方法，但是实际的实现留给了跟踪基础设施。例如，蹦床是一种允许在运行时进行插装的机制，但是蹦床的实际实现留给了诸如DynInst或Kprobes之类的跟踪基础设施。类似地，一个工具可以支持多种机制，并允许其用户根据自己的需要配置要使用的机制。然后可以在这些技术上构建跟踪器，以利用它们的回调机制，从而外包这个关键部分。可以构建跟踪程序来支持多个回调机制，从而获得更好的灵活性和特性。总之，跟踪程序可以使用一个或多个回调实现，而这些回调实现又实现一个或多个机制。例如，LTTng可以使用TRACE_EVENT或Kprobes，而Kprobes可以使用trap或trampoline。

We define a tracer as a tool that implements the following pattern: callback, serialize, write. The output of a tracer is a trace, and efforts are dedicated to reducing as much as possible its overhead. On the other hand, tools such as eBPF and SystemTap fundamentally follow a different pattern: callback, compute, update. We refer to them as aggregators, since their work is often to collect and aggregate metrics in real time or in a live fashion, on the critical path of the applications, contrary to the post-mortem nature of trace analysis. To this end, they provide users with scripting capabilities and advanced data structures (such as hashmaps) to implement aggregation methods to be executed upon certain events. As opposed to tracers, the output of aggregators is the result of the user-defined probe, which is typically a collection of metrics, an alert when a threshold is exceeded at runtime, and so on. They often neglect the timing aspect and don’t implicitly perform a clock read on each callback.

我们将跟踪器定义为实现以下模式的工具: 回调、串行化、写入。跟踪器的输出是一个轨迹，并且致力于尽可能减少其开销。另一方面，eBPF 和 SystemTap 等工具基本上遵循不同的模式: 回调、计算、更新。我们称他们为聚合器，因为他们的工作通常是在应用程序的关键路径上实时或实时收集和聚合指标, 与微量分析的死后性质相反。为此，它们为用户提供脚本功能和高级数据结构 (如 hashmaps)，以实现在某些事件上执行的聚合方法。与示踪剂不同，聚合器的输出是用户定义的探测器的结果，通常是度量的集合，在运行时超过阈值时发出警报, 等等。他们经常忽略时间方面，并且不会在每个回调上隐含地执行时钟读取。

8 CONCLUSION

In this article, we explained the designs of different kernel and USTs. The benchmark results not only helped to quantify the overhead that each tracer adds to the traced application, but also point out specific details about the internals of each tracer. By sampling low-level performance counters, this analysis helps users determine where the overhead usually originates from, and how to configure tracers to reduce their footprint depending on their requirements. Lastly, this research also helps tracer developers, as we were able to point out potential optimizations in some tracers, and showed design limitations in others. In conclusion, designing a tracer is a trade-off between usability, features, and overhead. Fundamental design choices have to be made that dictate how the tracer behaves under critical conditions.

在这篇文章中，我们解释了不同内核和 USTs 的设计。基准测试结果不仅有助于量化每个跟踪器增加跟踪应用程序的开销，还可以指出每个跟踪器内部的具体细节。通过对低级性能计数器进行采样，这种分析有助于用户确定开销通常来自哪里，以及如何根据用户的需求配置 tracer 来减少占用空间。最后，这项研究也有助于 tracer 开发人员，因为我们能够指出一些 tracer 中的潜在优化，并在其他 tracer 中显示设计局限性。总之，设计跟踪器是可用性、特性和开销之间的权衡。必须做出基本的设计选择，决定示踪剂在关键条件下的行为。
