# Automatic Software Repair: A Bibliography

## 1 INTRODUCTION
This article presents an annotated bibliography on automatic software repair. Automatic software repair consists of automatically finding a solution to software bugs1 without human intervention. This idea of automatically repairing software bugs is both important and challenging. It is important because software has eaten the world,2 but, unfortunately, each bite comes with bugs. The software we daily use sometimes crashes, sometimes gives erroneous results, and sometimes even kills people [87]. We do have millions of bugs in the wild, and many of them are being created every day in new software products and releases. To summarize, if automatic software repair could  only repair a fraction of those bugs, then it would bring value to society and humanity.
Automatic software repair is challenging because fixing bugs is a difficult task. Of course there are stupid bugs—“blunder” as Knuth puts it [82]—that can be trivially fixed. However, any programmer, whether professional or hobbyist, remembers a bug that took him or her hours, if not days and weeks, to be understood and fixed; these are the “hairiest bugs” [43]. For those bugs,
automatic repair is a challenging human-competitive task.

这篇文章介绍了一个关于自动软件修复的注释书目。自动软件修复包括自动寻找软件漏洞的解决方案，无需人工干预。这种自动修复软件错误的想法既重要又具有挑战性。这一点很重要，因为软件已经吞噬了世界，但是不幸的是，每一次叮咬都会带来错误。我们日常使用的软件有时会崩溃，有时会给出错误的结果，有时甚至会杀死人 [87]。我们确实有数百万个漏洞，其中许多漏洞每天都在新的软件产品和发布中被创造出来。总而言之，如果自动软件修复只能修复其中的一小部分错误，那么它将为社会和人类带来价值。
自动软件修复具有挑战性，因为修复错误是一项艰巨的任务。当然，也有一些愚蠢的错误 -- 正如克努特所说的 “失误”，[82] -- 可以简单地修复。然而，任何程序员，无论是专业人员还是业余爱好者，都记得一个花了他或她的时间 (如果不是几天或几周) 来理解和修复的错误; 这些是 “最海的虫子” [43]。对于这些错误，自动修复是一项具有挑战性的人类竞争任务。

The goal of this article is to draw the big picture of automatic software repair. In particular, it aims at presenting together the two main families of automatic repair techniques: behavioral repair and state repair. The former is about automatically modifying the program code; the latter is about automatically modifying the execution state at runtime. The primary intended audience consists of researchers in computer science, with a focus on the research communities that contribute to this body of knowledge: software engineering, dependability, operating systems, programminglanguages, and software security. Each section also provides an introductory explanation of the key concepts behind automatic repair, which could be of high interest for practitioners and curious students. This survey aims at covering all important works in the field or automatic software
repair, with an emphasis on empiricism: the covered technique must apply to some programs done in industry and bugs that happen in practice. Works are included as follows: For each article, the importance is qualified according to the visibility and reputation of the venue or the novelty of the idea presented in the article. If several articles contain the same idea, then only the most representative one is discussed and cited. It is to be noted that the same concept “repair” has several names in the literature: “patch,” “fix,” “heal,” “recover,” and so on. Table 1 lists the main ones, as well as notable references that use the term. In this article, the name “repair” is chosen, because a program has something mechanical in nature, which fits well the daily usage of the word “repair.” Also, it is the name used by the most excellent articles in the field.

这篇文章介绍了一个关于自动软件修复的注释书目。自动软件修复包括自动寻找软件漏洞的解决方案，无需人工干预。这种自动修复软件错误的想法既重要又具有挑战性。这一点很重要，因为软件已经吞噬了世界，但是不幸的是，每一次叮咬都会带来错误。我们日常使用的软件有时会崩溃，有时会给出错误的结果，有时甚至会杀死人 [87]。我们确实有数百万个漏洞，其中许多漏洞每天都在新的软件产品和发布中被创造出来。总而言之，如果自动软件修复只能修复其中的一小部分错误，那么它将为社会和人类带来价值。
自动软件修复具有挑战性，因为修复错误是一项艰巨的任务。当然，也有一些愚蠢的错误 -- 正如克努特所说的 “失误”，[82] -- 可以简单地修复。然而，任何程序员，无论是专业人员还是业余爱好者，都记得一个花了他或她的时间 (如果不是几天或几周) 来理解和修复的错误; 这些是 “最海的虫子” [43]。对于这些错误，自动修复是一项具有挑战性的人类竞争任务。