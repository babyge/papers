# Automatically Generating Fix Suggestions in Response to Static Code Analysis Warnings

## Abstract

Static code analysis tools such as FindBugs and SonarQube are widely used on open-source and industrial projects to detect a variety of issues that may negatively affect the quality of software. Despite these tools’ popularity and high level of automation, several empirical studies report that developers normally fix only a small fraction (typically, less than 10% [1]) of the reported issues—so-called “warnings”. If these analysis tools could also automatically provide suggestions on how to fix the issues that trigger some of the warnings, their feedback would become more actionable and more directly useful to developers.

FindBugs和SonarQube等静态代码分析工具在开源和工业项目中广泛使用，用于检测各种可能对软件质量产生负面影响的问题。尽管这些工具很受欢迎，自动化程度也很高，但一些实证研究报告称，开发人员通常只修复报告问题中的一小部分(通常少于10%的[1])，即所谓的“警告”。如果这些分析工具还能够自动提供关于如何修复触发某些警告的问题的建议，那么它们的反馈将变得更有可操作性，并且对开发人员更直接有用。

In this work, we investigate whether it is feasible to automatically generate fix suggestions for common warnings issued by static code analysis tools, and to what extent developers are willing to accept such suggestions into the codebases they’re maintaining. To this end, we implemented a Java program transformation technique that fixes 11 distinct rules checked by two well-known static code analysis tools (SonarQube and SpotBugs). Fix suggestions are generated automatically based on templates, which are instantiated in a way that removes the source of the warnings; templates for some rules are even capable of producing multi-line patches. We submitted 38 pull requests, including 920 fixes generated automatically by our technique for various open-source Java projects, including the Eclipse IDE and both SonarQube and SpotBugs tools. At the time of writing, project maintainers accepted 84% of our fix suggestions (95% of them without any modifications). These results indicate that our approach to generating fix suggestions is feasible, and can help increase the applicability of static code analysis tools.

在这项工作中，我们研究了为静态代码分析工具发出的常见警告自动生成修复建议是否可行，以及开发人员愿意在多大程度上将这些建议加入到他们维护的代码库中。为此，我们实现了一个Java程序转换技术，该技术修复了由两个著名的静态代码分析工具(SonarQube和SpotBugs)检查的11个不同规则。修复建议根据模板自动生成，模板的实例化方式消除了警告的来源;一些规则的模板甚至能够生成多行补丁。我们提交了38个pull请求，包括920个由我们的技术为各种开源Java项目自动生成的修复，包括Eclipse IDE和SonarQube和SpotBugs工具。在撰写本文时，项目维护者接受了84%的修复建议(其中95%没有进行任何修改)。这些结果表明我们生成修复建议的方法是可行的，并且可以帮助增加静态代码分析工具的适用性。

## I. INTRODUCTION

Static code analysis tools (SATs) are becoming increasingly popular as a way of detecting possible sources of defects earlier in the development process [2]. By working statically on the source or byte code of a project, these tools are applicable to large code bases [3], [4], where they quickly search for patterns that may indicate problems—bugs, questionable design choices, or failures to follow stylistic conventions [5], [6]—and report them to users. There is evidence [7] that using these tools can help developers monitor and improve software code quality; indeed, static code analysis tools are widely used for both commercial and open-source software development [1], [2], [4]. Some projects’ development rules even require that code has to clear the checks of a certain SAT before it can be released [1], [7], [8].

静态代码分析工具(SATs)作为一种在开发过程[2]的早期检测缺陷的可能来源的方法，正变得越来越流行。通过静态地处理项目的源代码或字节代码，这些工具适用于大型代码库[3]和[4]，在这些代码库中，它们可以快速搜索可能指出问题(bug、有问题的设计选择或未能遵循[5]和[6]的风格约定)的模式，并向用户报告这些问题。有证据表明，使用这些工具可以帮助开发人员监视和改进软件代码质量;事实上，静态代码分析工具被广泛用于商业和开源软件开发的[1]、[2]、[4]。一些项目的开发规则甚至要求代码在发布[1]、[7]、[8]之前必须清除特定SAT的检查。

At the same time, some features of SATs limit their wider applicability in practice. One key problem is that SATs are necessarily imprecise in checking for rule violations; in other words, they report warnings that may or may not correspond to an actual mistake. As a result, the first time a static analysis tool is run on a project, it is likely to report thousands of warnings [2], [3], which saturates the developers’ capability of sifting through them to select those that are more relevant and should be fixed [1]. Another related issue with using SATs in practice is that understanding the problem highlighted by a warning and coming up with a suitable fix is often nontrivial [1], [3].

与此同时，sat考试的一些特点限制了其在实践中的广泛适用性。一个关键问题是，sat在检查违反规则的情况时必然不够精确;换句话说，他们报告的警告可能与实际的错误相符，也可能不相符。因此，第一次在项目上运行静态分析工具时，它可能会报告成千上万个警告[2]、[3]，这将使开发人员的筛选能力达到饱和，以选择那些更相关且应该修复的[1]。在实践中使用SATs的另一个相关问题是，理解由警告突出显示的问题并提出合适的修复方案通常是非常重要的[1]和[3]。

Our research aims at improving the practical usability of SATs by automatically providing fix suggestions: modifications to the source code that make it compliant with the rules checked by the analysis tools. We developed an approach, called SpongeBugs and described in Section III, whose current implementation works on Java code. SpongeBugs detects violations of 11 different rules checked by SonarQube and SpotBugs (successor to FindBugs [2])—two well-known static code analysis tools, routinely used by very many software companies and consortia, including large ones such as the Apache Software Foundation and the Eclipse Foundation. The rules checked by SpongeBugs are among the most widely used in these two tools, and cover different kinds of code issues (ranging from performance, to correct behavior, style, and other aspects). For each violation it detects, SpongeBugs automatically generates a fix suggestion and presents it to the user.

我们的研究旨在通过自动提供修复建议来提高SATs的实际可用性:对源代码进行修改，使其符合分析工具检查的规则。我们开发了一种称为SpongeBugs的方法，并在第三节中进行了描述，该方法的当前实现工作在Java代码上。SpongeBugs检测违反SonarQube和SpotBugs (FindBugs[2]的继承者)检查的11种不同规则的行为，这是两个著名的静态代码分析工具，经常被很多软件公司和协会使用，包括大型的Apache软件基金会和Eclipse基金会。海绵bug检查的规则是这两个工具中使用最广泛的规则之一，涵盖了不同类型的代码问题(从性能到正确的行为、样式和其他方面)。对于它检测到的每一个违规，海绵漏洞会自动生成一个修复建议并呈现给用户。

By construction, SpongeBugs’s suggestions remove the origin of a rule’s violation, but the maintainer still has to decide—based on their overall knowledge of the project— whether to accept and merge each suggestion. To assess whether developers are indeed willing to accept SpongeBugs’s suggestions, Section V describes the results of an empirical evaluation where we applied SpongeBugs to 12 Java projects, and submitted 920 fix suggestions as pull requests to the projects. At the time of writing, project maintainers accepted 775 (84%) fix suggestions—95% of them without any modifications. This high acceptance rate suggests that SpongeBugs often generates patches of high quality, which developers find adequate and useful. The empirical evaluation also indicates that SpongeBugs is applicable with good performance to large code bases; and reports (in Section V-D) several qualitative findings that can inform further progress in this line of work.

通过构造，SpongeBugs的建议消除了规则违反的来源，但是维护人员仍然需要根据他们对项目的总体了解来决定——是否接受并合并每一个建议。为了评估开发人员是否真的愿意接受SpongeBugs的建议，第五部分描述了一个经验评估的结果，我们将SpongeBugs应用到12个Java项目中，并将920个修复建议作为拉请求提交给项目。在撰写本文时，项目维护者接受了775(84%)个修复建议——其中95%没有进行任何修改。如此高的通过率表明，海绵细菌通常会生成高质量的补丁，开发人员认为这些补丁足够且有用。实证评价还表明，海绵漏洞在大型代码库中具有良好的应用性能;并报告(V-D节)几项质量发现，这些发现可为这一行工作的进一步进展提供资料。

The work reported in this paper is part of a large body of research (see Section II) that deals with helping developers detecting and fixing bugs and code smells. SpongeBugs’ approach is characterized by the following features: i) it targets static rules that correspond to frequent mistakes that are often fixable syntactically; ii) it builds fix suggestions that remove the source of warning by construction; iii) it scales to large code bases because it is based on lightweight program transformation techniques. Despite the focus on conceptually simple rule violations, SpongeBugs can generate nontrivial patches, including some that modify multiple hunks of code at once. In summary, SpongeBugs’s focus privileges generating a large number of practically useful fixes over being as broadly applicable as possible. Based on our empirical evaluation, Section VI discusses the main limitations of SpongeBugs’s approach, and Section VII outlines directions for further progress in this line of work.

本文中报告的工作是大量研究的一部分(参见第二部分)，这些研究旨在帮助开发人员检测和修复bug和代码气味。海绵宝宝的方法有以下特点:1)它针对的是静态规则，这些规则对应的是经常出现的错误，这些错误在语法上通常是可以修复的;ii)通过构建修正建议，消除构建的警告源;它可以扩展到大型的代码库，因为它基于轻量级的程序转换技术。尽管海绵漏洞关注的是概念上的简单规则违规，但它可以生成重要的补丁，包括一些一次性修改多块代码的补丁。总而言之，海绵宝宝的焦点特权产生了大量实际有用的修复比尽可能广泛地应用。基于我们的经验评估，第六部分讨论了海绵宝宝的方法的主要局限性，第七部分概述了在这方面工作的进一步发展方向。

## II. BACKGROUND AND RELATED WORK

Static analysis techniques reason about program behavior statically, that is without running the program [9]. This is in contrast to dynamic analysis techniques, which are instead driven by specific program inputs (provided, for example, by unit tests). Thus, static analysis techniques are often more scalable (because they do not require complete executions) but also less precise (because they over-approximate program behavior to encompass all possible inputs) than dynamic analysis techniques. In practice, there is a broad range of static analysis techniques from purely syntactic ones—based on code patterns—to complex semantic ones—which infer behavioral properties that can be used to perform program optimizations [10], [11] as well as performance problems and other kinds of vulnerabilities [12], [13].

静态分析技术静态地分析程序行为，即不运行程序[9]。这与动态分析技术相反，动态分析技术是由特定的程序输入驱动的(例如，由单元测试提供)。因此，静态分析技术通常比动态分析技术具有更大的可伸缩性(因为它们不需要完全执行)，但也不像动态分析技术那样精确(因为它们过于接近程序行为以包含所有可能的输入)。在实践中，有很广泛的静态分析技术，从基于代码模式的纯语法技术到复杂的语义技术，这些技术可以推断出行为属性，可以用来执行程序优化[10]、[11]以及性能问题和其他类型的漏洞[12]、[13]。

Static Code Analysis Tools. Static code analysis tools (SATs) typically combine different kinds of analyses. This paper focuses on the output of tools such as SonarQube, FindBugs, and SpotBugs, because they are widely available and practically used [2]. The analysis performed by a SAT consists of several independent rules, which users can select in every run of the tool. Each rule describes a requirement that correct, high-quality code should meet. For example, a rule may require that Constructors should not be used to instantiate String—one should write String s = "SpongeBugs" instead of String s = new String("SpongeBugs").

静态代码分析工具。静态代码分析工具(SATs)通常结合不同类型的分析。本文主要关注SonarQube、FindBugs和SpotBugs等工具的输出，因为它们广泛可用，并且在实际中使用了[2]。SAT执行的分析由几个独立的规则组成，用户可以在每次运行该工具时选择这些规则。每个规则都描述了正确的、高质量的代码应该满足的需求。例如，规则可能要求构造函数不能用来实例化字符串——应该写String s = "SpongeBugs"而不是String s = new String("SpongeBugs")。

